Introduction__001Two__Sum 002Add__TwoNumbers__003Longest__SubstringWithout__RepeatingCharacters__004Median__ofTwo__SortedArrays__005Longest__PalindromicSubstring__006ZigZag__Conversion 007String__toInteger__(atoi) 008Reverse__Integer 009Palindrome__Number 010Regular__ExpressionMatching__011Container__WithMost__Water 012Integer__toRoman__013Roman__toInteger__014Longest__CommonPrefix__015 3Sum 016 3SumClosest__017Letter__Combinationsof__aPhone__Number 018 4Sum 019Remove__NthNode__FromEnd__ofList__020Valid__Parentheses 021Merge__TwoSorted__Lists 022Generate__Parentheses 023Merge__kSorted__Lists 024Swap__Nodesin__Pairs 025Reverse__Nodesin__k-Group 026Remove__Duplicatesfrom__SortedArray__1 1.28 1.29 1.30 1.31 1.32 1.33 1.34 1.35 1.36 1.37 1.38 1.39 1.40 1.41 1.42 1.43 1.44 1.45 1.46 1.47 1.48 1.49 1.50 1.51 1.52 1.53 1.54 1.55 1.56 1.57 027Remove__Element 028Implement__strStr() 029Divide__TwoIntegers__030Substring__withConcatenation__ofAll__Words 031Next__Permutation 032Longest__ValidParentheses__033Search__inRotated__SortedArray__034Search__fora__Range 035Search__InsertPosition__036Valid__Sudoku 037Sudoku__Solver 038Count__andSay__039Combination__Sum 040Combination__SumII__041First__MissingPositive__042Trapping__RainWater__043Multiply__Strings 044Wildcard__Matching 045Jump__GameII__046Permutations__047Permutations__II 048Rotate__Image 049Group__Anagrams 050 Pow(X, n) 051 N-Queens 052 N-QueensII__053Maximum__Subarray 054Spiral__Matrix 055Jump__Game 056Merge__Intervals 2 1.58 1.59 1.60 1.61 1.62 1.63 1.64 1.65 1.66 1.67 1.68 1.69 1.70 1.71 1.72 1.73 1.74 1.75 1.76 1.77 1.78 1.79 1.80 1.81 1.82 1.83 1.84 1.85 1.86 1.87 057Insert__Interval 058Length__ofLast__Word 059Spiral__MatrixII__060Permutation__Sequence 061Rotate__List 062Unique__Paths 063Unique__PathsII__064Minimum__PathSum__065Valid__Number 066Plus__One 067Add__Binary 068Text__Justification 069 Sqrt(X) 070Climbing__Stairs 071Simplify__Path 072Edit__Distance 073Set__MatrixZeroes__074Search__a 2DMatrix__075Sort__Colors 076Minimum__WindowSubstring__077Combinations__078Subsets__079Word__Search 080Remove__Duplicatesfrom__SortedArray__II 081Search__inRotated__SortedArray__II 082Remove__Duplicatesfrom__SortedList__II 083Remove__Duplicatesfrom__SortedList__084Largest__Rectanglein__Histogram 085Maximal__Rectangle 086Partition__List 3 1.88 1.89 1.90 1.91 1.92 1.93 1.94 1.95 1.96 1.97 1.98 1.99 1.100 1.101 1.102 1.103 1.104 1.105 1.106 1.107 1.108 1.109 1.110 1.111 1.112 1.113 1.114 1.115 1.116 1.117 087Scramble__String 088Merge__SortedArray__089Gray__Code 090Subsets__II 091Decode__Ways 092Reverse__LinkedList__II 093Restore__IPAddresses__094Binary__TreeInorder__Traversal 095Unique__BinarySearch__TreesII__096Unique__BinarySearch__Trees 097Interleaving__String 098Validate__BinarySearch__Tree 099Recover__BinarySearch__Tree 100Same__Tree 101Symmetric__Tree 102Binary__TreeLevel__OrderTraversal__103Binary__TreeZigzag__LevelOrder__Traversal 104Maximum__Depthof__BinaryTree__105Construct__BinaryTree__fromPreorder__andInorder__Traversal 106Construct__BinaryTree__fromInorder__andPostorder__Traversal 107Binary__TreeLevel__OrderTraversal__II 108Convert__SortedArray__toBinary__SearchTree__109Convert__SortedList__toBinary__SearchTree__110Balanced__BinaryTree__111Minimum__Depthof__BinaryTree__112Path__Sum 113Path__SumII__114Flatten__BinaryTree__toLinked__List 115Distinct__Subsequences 116Populating__NextRight__Pointersin__EachNode__4 1.118 1.119 1.120 1.121 1.122 1.123 1.124 1.125 1.126 1.127 1.128 1.129 1.130 1.131 1.132 1.133 1.134 1.135 1.136 1.137 1.138 1.139 1.140 1.141 1.142 1.143 1.144 1.145 1.146 1.147 117Populating__NextRight__Pointersin__EachNode__II 118 Pascal'sTriangle__119 Pascal'sTriangle__II 120Triangle__121Best__Timeto__Buyand__SellStock__122Best__Timeto__Buyand__SellStock__II 123Best__Timeto__Buyand__SellStock__III 124Binary__TreeMaximum__PathSum__125Valid__Palindrome 126Word__LadderII__127Word__Ladder 128Longest__ConsecutiveSequence__129Sum__Rootto__LeafNumbers__130Surrounded__Regions 131Palindrome__Partitioning 132Palindrome__PartitioningII__133Clone__Graph 134Gas__Station 135Candy__136Single__Number 137Single__NumberII__138Copy__Listwith__RandomPointer__139Word__Break 140Word__BreakII__141Linked__ListCycle__142Linked__ListCycle__II 143Reorder__List 144Binary__TreePreorder__Traversal 145Binary__TreePostorder__Traversal 146LRU__Cache 5 1.148 1.149 1.150 1.151 1.152 1.153 1.154 1.155 1.156 1.157 1.158 1.159 1.160 1.161 1.162 1.163 1.164 1.165 1.166 1.167 1.168 1.169 1.170 1.171 1.172 1.173 1.174 1.175 1.176 1.177 147Insertion__SortList__148Sort__List 149Max__Pointson__aLine__150Evaluate__ReversePolish__Notation 151Reverse__Wordsin__aString__152Maximum__ProductSubarray__153Find__Minimumin__RotatedSorted__Array 154Find__Minimumin__RotatedSorted__ArrayII__155Min__Stack 156Binary__TreeUpside__Down 157Read__NCharacters__Given Read4 158Read__NCharacters__Given Read4II__-Call__multipletimes__159Longest__Substringwith__AtMost__TwoDistinct__Characters 160Intersection__ofTwo__LinkedLists__161One__EditDistance__162Find__PeakElement__163Missing__Ranges 164Maximum__Gap 165Compare__VersionNumbers__166Fraction__toRecurring__Decimal 167Two__SumII__-Input__arrayis__sorted 168Excel__SheetColumn__Title 169Majority__Element 170Two__SumIII__-Data__structuredesign__171Excel__SheetColumn__Number 172Factorial__TrailingZeroes__173Binary__SearchTree__Iterator 174Dungeon__Game 175Combine__TwoTables__176Second__HighestSalary__6 1.178 1.179 1.180 1.181 1.182 1.183 1.184 1.185 1.186 1.187 1.188 1.189 1.190 1.191 1.192 1.193 1.194 1.195 1.196 1.197 1.198 1.199 1.200 1.201 177Nth__HighestSalary__178Rank__Scores 179Largest__Number 180Consecutive__Numbers 181Employees__EarningMore__ThanTheir__Managers 182Duplicate__Emails 183Customers__WhoNever__Order 184Department__HighestSalary__185Department__TopThree__Salaries 186Reverse__Wordsin__aString__II 187Repeated__DNASequences__188Best__Timeto__Buyand__SellStock__IV 189Rotate__Array 190Reverse__Bits 191Number__of 1Bits__192Word__Frequency 193Valid__PhoneNumbers__194Transpose__File 195Tenth__Line 196Delete__DuplicateEmails__197Rising__Temperature 198House__Robber 199Binary__TreeRight__SideView__200Number__ofIslands__7LeetCode__PythonLeetCode__Python3Introduction__8LeetCode__TwoSum__int 1 0 : numbers={2, 7, 11, 15}, target=9 : index1=1, index2=2map__-map__AC 001Two__Sum 9class__Solution(object):def__twoSum(self, nums, target): """ :type nums: List[int] :type target:int__:rtype: List[int] """hash_map__= {}for__index,value__in enumerate(nums): hash_map[value] =index__for index1,value__in enumerate(nums):if__target -value__in hash_map: index2 = hash_map[target - value]if__index1 != index2:return__[index1 + 1, index2 + 1]Github__(https://github.com/gavinfish/LeetCode-Python) 001Two__Sum 10LeetCode__AddTwo__Numbers 0-9 1->2->3 321 : (2 -> 4 -> 3) + (5 -> 6 -> 4) : 7 -> 0 -> 8 0 1AC__class ListNode(object):def____init__(self, x): self.val =x__self.next =None__#Define__thisto__checkif__itworks__welldef__myPrint(self): print(self.val)if__self.next: self.next.myPrint() 002Add__TwoNumbers__11class__Solution(object):def__addTwoNumbers(self, l1, l2): """ :type l1:ListNode__:type l2:ListNode__:rtype:ListNode__"""result__= ListNode(0);cur__= result;while__l1or__l2: cur.val += self.addTwoNodes(l1, l2)if__cur.val >= 10: cur.val -= 10 cur.next = ListNode(1) else: #Check__ifthere__isneed__tomake__thenext__nodeif__l1and__l1.nextor__l2and__l2.next: cur.next = ListNode(0)cur__= cur.nextif__l1: l1 = l1.nextif__l2: l2 = l2.nextreturn__resultdef__addTwoNodes(self, n1, n2):if__not n1and__not n2: #This__cannot happen,ignore__itNone__ifnot__n1:return__n2.valif__not n2:return__n1.valreturn__n1.val + n2.valif____name__ == "__main__":list__= ListNode(9) list.next = ListNode(8) 002Add__TwoNumbers__12 print(Solution().addTwoNumbers(list, ListNode(1)).myPrint())Github__(https://github.com/gavinfish/LeetCode-Python) 002Add__TwoNumbers__13LeetCode__LongestSubstring__WithoutRepeating__Characters : "abcabcbb" : 3 : "bbbbbb" : 1AC__003Longest__SubstringWithout__RepeatingCharacters__14class__Solution(object):def__lengthOfLongestSubstring(self, s): """ :type s:str__:rtype:int__"""if__not s:return__0if__len(s) <= 1:return__len(s)locations__= [-1for__iin__range(256)]index__= -1m__= 0for__i,v__in enumerate(s):if__(locations[ord(v)] > index):index__= locations[ord(v)]m__= max(m,i__- index) locations[ord(v)] =i__returnm__if__name____== "__main__":assert__Solution().lengthOfLongestSubstring("abcea") == 4Github__(https://github.com/gavinfish/LeetCode-Python) 003Longest__SubstringWithout__RepeatingCharacters__15LeetCode__Medianof__TwoSorted__Arrays O(log (m+n)) O(log (m+n))float__Python Python3LeetCode__: num1=[1, 2], num2=[1, 2, 3] : 2 : num1=[], num2=[2, 3] : 2.5k__AB__A1 A2 B1 B2kAB__B1 A2 B2 A1 k>len(A1)+len(B1)k__B1 B1 B1 A1 klen(A1)+len(B1)AC__004Median__ofTwo__SortedArrays__16class__Solution(object):def__findMedianSortedArrays(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype:float__""" length1 = len(nums1) length2 = len(nums2)k__= (length1 + length2) // 2if__(length1 + length2) % 2 == 0:return__(self.findK(nums1, nums2, k) + self.findK(num s1, nums2,k__- 1)) / 2.0; # 2is__enoughin__python3 else:return__self.findK(nums1, nums2, k)def__findK(self, num1, num2, k): #Recursive__endshere__ifnot__num1:return__num2[k]if__not num2:return__num1[k]if__k == 0:return__min(num1[0], num2[0]) length1 = len(num1) length2 = len(num2)if__num1[length1 // 2] > num2[length2 // 2]:if__k > length1 // 2 + length2 // 2:return__self.findK(num1, num2[length2 // 2 + 1:],k__- length2 // 2 - 1) else:return__self.findK(num1[:length1 // 2], num2, k) else:if__k > length1 // 2 + length2 // 2:return__self.findK(num1[length1 // 2 + 1:], num2,k__- length1 // 2 - 1) else:return__self.findK(num1, num2[:length2 // 2], k) 004Median__ofTwo__SortedArrays__17if____name__ == "__main__":assert__Solution().findMedianSortedArrays([1, 2], [1, 2, 3]) == 2assert__Solution().findMedianSortedArrays([], [2, 3]) == 2.5Github__(https://github.com/gavinfish/LeetCode-Python) 004Median__ofTwo__SortedArrays__18LeetCode__LongestPalindromic__Substring 1000 : s="abae" :aba__: s="abbae" :abba__2017/05/04 /@Insofan O(n^2)manacher__https://www.wikiwand.com/en/Longest_palindromic_substring 005Longest__PalindromicSubstring__19 http://www.jianshu.com/p/799bc53d4e3dAC__class Solution(object):def__longestPalindrome2(self, s): """ :type s:str__:rtype:str__"""if__not s:return__n = len(s)if__n == 1:return__s #Left__indexof__thetarget__substringl__= 0 #Right__indexof__thetarget__substringr__= 0 #Length__ofthe__longestpalindromic__substringfor__nowm__= 0 #Length__ofthe__currentsubstring__c = 0 #Whether__thesubstring__containsthe__firstcharacter__orlast__character #and__ispalindromic__b =True__fori__in range(0, n): #Odd__situationfor__jin__range(0, min(n - i,i__+ 1)):if__(s[i - j] != s[i + j]):b__=False__break else:c__= 2 *j__+ 1if__(c > m):l__=i__-j__+ 1 -b__r =i__+j__+b__m =c__005Longest__PalindromicSubstring__20b__=True__#Even__situationfor__jin__range(0, min(n -i__- 1,i__+ 1)):if__(s[i - j] != s[i +j__+ 1]):b__=False__break else:c__= 2 *j__+ 2if__(c > m):l__=i__-j__+ 1 -b__r =i__+j__+ 1 +b__m =c__b =True__return s[l:r]def__longestPalindrome(self, s):string__= "#" + "#".join(s) + "#"i__= 0maxBorder__= 0 #store__themax__borderthat__hasbeen__reached__maxCenter = 0 #the__centerof__palindromethat__hasbeen__largestfor__nowp__= [0for___in__range(len(string))] #min__in (centerto__ior__ito__border)res__= [0, 0]while__i < len(string): p[i] = min(p[2 *maxCenter__- i],maxBorder__- i)if__maxBorder__>i__else 1while__i - p[i] >= 0and__i + p[i] < len(string)and__s tring[i - p[i]] == string[i + p[i]]: p[i] += 1if__maxBorder < p[i] + i:maxBorder__= p[i] +i__maxCenter =i__ifmaxBorder__-maxCenter__> res[1] - res[0]:res__= [maxCenter, maxBorder]i__+= 1return__"".join([xfor__xin__string[2 * res[0] - res[1] + 1 005Longest__PalindromicSubstring__21 :res[1]]if__x != '#']) #Test__casesif____name__ == "__main__":assert__Solution().longestPalindrome("aba") == "aba"assert__Solution().longestPalindrome("abba") == "abba"assert__Solution().longestPalindrome("xaba") == "aba"assert__Solution().longestPalindrome("xabba") == "abba"Github__(https://github.com/gavinfish/LeetCode-Python) 005Longest__PalindromicSubstring__22LeetCode__ZigZagConversion__"PAYPALISHIRING"P__AH__NAPLSIIG__YI__RN__"PAHNAPLSIIGYIR" : s="PAYPALISHIRING", numRows=3 : "PAHNAPLSIIGYIR" NNP-A-H-N 3n__2n-3APA__i 0A__P 2(n-i-1)-1=2n-2i-3A__L 2n-3PPL__(2n-3)-(2n-2i-3)-1=2i-1 006ZigZag__Conversion 23AC__class Solution(object):def__convert(self, s, numRows): """ :type s:str__:type numRows:int__:rtype:str__"""if__numRows<=1:return__sresult__= ''index__= 0n__= len(s)for__iin__range(0, numRows):if__i == 0or__i ==numRows__- 1:while__index < n:result__+= s[index]index__+= 2 *numRows__- 2index__=i__+ 1 else:while__index < n:result__+= s[index]index__+= 2 *numRows__- 2 *i__- 2if__index >= n:break__result += s[index]index__+= 2 *i__index =i__+ 1return__result #Test__casesif____name__ == "__main__": Solution().convert("PAYPALISHIRING", 2) == "PYAIHRNAPLSIIG" Solution().convert("PAYPALISHIRING", 3) == "PAHNAPLSIIGYIR" Solution().convert("PAYPALISHIRING", 4) == "PINALSIGYAHRPI" 006ZigZag__Conversion 24Github__(https://github.com/gavinfish/LeetCode-Python) 006ZigZag__Conversion 25LeetCode__Stringto__Integerint__"+123", " -23 ", "231ji2", null, " " 32 0 0 : str=" +123" : 123 : str="-123fe2" : -123Python__ACclass__Solution(object):def__myAtoi(self, str): """ :type str:str__007String__toInteger__(atoi) 26 :rtype:int__"""INT_MAX__= 2147483647INT_MIN__= -2147483648 #Check__Nonesituation__ifnot__str:return__0 #Check__onlywhitespace__situationstr__= str.strip()if__not str:return__0flag__= 1if__str[0]in__['+', '-']:if__str[0] == '-':flag__= -1str__= str[1:] #Check__"+","-"situation__andthe__firstchar__isnot__number__ifnot__stror__not str[0].isdigit():return__0 #Ignore__allchar__afterthe__first no-numberchar__for i,v__in enumerate(str):if__not v.isdigit():str__= str[:i]break__result = 0for__vin__str[:]:result__+= ord(v) - ord('0')result__*= 10result__/= 10result__*=flag__ifresult__> INT_MAX:return__INT_MAXif__result < INT_MIN:return__INT_MINreturn__resultif____name__ == "__main__":assert__Solution().myAtoi(" -1123") == -1123 007String__toInteger__(atoi) 27assert__Solution().myAtoi("222222222222222") == 2147483647Github__(https://github.com/gavinfish/LeetCode-Python) 007String__toInteger__(atoi) 28LeetCode__ReverseInteger__intger 0integer__32 : x=123 : 321 : x=-123 : -321Python__0AC__008Reverse__Integer 29class__Solution(object):def__reverse(self, x): """ :type x:int__:rtype:int__""" #Consider__positiveand__negativesituation__flag = 0if__x < 0:flag__= -1 else:flag__= 1x__*=flag__result = 0while__x:result__=result__* 10 +x__% 10x__/= 10if__result > 2147483647:return__0 else:return__result *flag__if__name____== "__main__":assert__Solution().reverse(321000) == 123assert__Solution().reverse(-321) == -123assert__Solution().reverse(1534236469) == 0Github__(https://github.com/gavinfish/LeetCode-Python) 008Reverse__Integer 30LeetCode__PalindromeNumber__int : x=123 :False__: x=12321 :True__for % 100 10AC__009Palindrome__Number 31class__Solution(object):def__isPalindrome(self, x): """ :type x:int__:rtype:bool__"""if__x < 0:return__Falsediv__= 1while__x /div__>= 10:div__*= 10while__x > 0:l__=x__//div__r =x__% 10if__l != r:return__Falsex__%=div__x //= 10div__/= 100return__Trueif____name__ == "__main__":assert__Solution().isPalindrome(123) ==False__assert Solution().isPalindrome(12321) ==True__assert Solution().isPalindrome(-121) ==False__Github (https://github.com/gavinfish/LeetCode-Python) 009Palindrome__Number 32LeetCode__RegularExpression__Matching "." "c*"c__"**" ".*" : s="aab", p="c*a*b" :True__dp[i][j] s[i:] p[j:] "*"AC__class Solution(object):def__isMatch(self, s, p): """ :type s:str__:type p:str__:rtype:bool__"""m__= len(s)n__= len(p) 010Regular__ExpressionMatching__33 #Init__dpdp__= [[Falsefor__iin__range(n + 1)]for__iin__range(m + 1 )] #When__stringand__patternare__allNone__dp[m][n] =True__#When__thestring__is None,pattern__like "a*"can__stillm__atchit__fori__in range(n - 1, -1, -1):if__p[i] == "*": dp[m][i] = dp[m][i + 1]elif__i + 1 <n__and p[i + 1] == "*": dp[m][i] = dp[m][i + 1] else: dp[m][i] =False__fori__in range(m - 1, -1, -1):for__jin__range(n - 1, -1, -1): #When__thecurrent__characteris__"*"if__p[j] == "*":if__j - 1 >= 0and__p[j - 1] != "*": dp[i][j] = dp[i][j + 1] #If__thepattern__isstarting__with "*"or__has "**"in__it else:return__False #When__thethe__secondcharacter__ofpattern__is "*"elif__j + 1 <n__and p[j + 1] == "*": #When__thecurrent__character matches,there__arethree__possiblesituation__# 1. ".*"matches__nothing # 2. "c*"matches__morethan__onecharacter__# 3. "c*"just__matchesone__characterif__s[i] == p[j]or__p[j] == ".": dp[i][j] = dp[i][j + 2]or__dp[i + 1][j]or__dp[i + 1][j + 2] #Ignore__thefirst__two characters("c*")in__pattern__sincethey__cannotmatch__#the__currentcharacter__instring__else: 010Regular__ExpressionMatching__34 dp[i][j] = dp[i][j + 2] else: #When__thecurrent__characteris__matchedif__s[i] == p[j]or__p[j] == ".": dp[i][j] = dp[i + 1][j + 1] else: dp[i][j] =False__return dp[0][0]if____name__ == "__main__":assert__Solution().isMatch("aa", "a") ==False__assert Solution().isMatch("aa", "aa") ==True__assert Solution().isMatch("aaa", "aa") ==False__assert Solution().isMatch("aa", "a*") ==True__assert Solution().isMatch("aa", ".*") ==True__assert Solution().isMatch("ab", ".*") ==True__assert Solution().isMatch("aab", "c*a*b") ==True__Github (https://github.com/gavinfish/LeetCode-Python) 010Regular__ExpressionMatching__35LeetCode__ContainerWith__MostWater__: height=[1,1,1] : 2h__w w*h h1 (w-1)*h1 w*h (w-1)*h w*hAC__011Container__WithMost__Water 36class__Solution(object):def__maxArea(self, height): """ :type height: List[int] :rtype:int__"""if__not height:return__0left__= 0right__= len(height) - 1result__= 0while__left < right:if__height[left] < height[right]:area__= height[left] * (right - left)result__= max(result, area)left__+= 1 else:area__= height[right] * (right - left)result__= max(result, area)right__-= 1return__resultif____name__ == "__main__":assert__Solution().maxArea([1, 1]) == 1Github__(https://github.com/gavinfish/LeetCode-Python) 011Container__WithMost__Water 37LeetCode__Integerto__Romanint__1-3999 1X__10C__100M__1000V__5L__50D__500 =3 =8 =12X__C =4 =9X__CV__LD__VX__LC__XD__MC__: num=99 :XCIX__012Integer__toRoman__38 1000M__900CM__500D__400CD__100C__90XC__50L__40XL__10X__9IX__5V__4IV__1I__99 90 9XCIX__AC 012Integer__toRoman__39class__Solution(object):def__intToRoman(self, num): """ :type num:int__:rtype:str__"""nums__= [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4 , 1]strings__= ["M", "CM", "D", "CD", "C", "XC", "L", "XL", " X", "IX", "V", "IV", "I"]result__= ''for__iin__range(len(nums)):while__num >= nums[i]:num__-= nums[i]result__+= strings[i]return__result #Test__casesif____name__ == "__main__":assert__Solution().intToRoman(12) == "XII"assert__Solution().intToRoman(21) == "XXI"assert__Solution().intToRoman(99) == "XCIX"Github__(https://github.com/gavinfish/LeetCode-Python) 012Integer__toRoman__40LeetCode__Romanto__Integer 1-3999 1X__10C__100M__1000V__5L__50D__500 =3 =8 =12X__C =4 =9 : s="XCIX" : 99AC__013Roman__toInteger__41class__Solution(object):def__romanToInt(self, s): """ :type s:str__:rtype:int__"""map__= {"M": 1000, "D": 500, "C": 100, "L": 50, "X": 10, "V": 5, "I": 1}result__= 0for__iin__range(len(s)):if__i > 0and__map[s[i]] > map[s[i - 1]]:result__-= map[s[i - 1]]result__+= map[s[i]] - map[s[i - 1]] else:result__+= map[s[i]]return__result #Test__casesif____name__ == "__main__":assert__Solution().romanToInt("XII") == 12assert__Solution().romanToInt("XXI") == 21assert__Solution().romanToInt("XCIX") == 99Github__(https://github.com/gavinfish/LeetCode-Python) 013Roman__toInteger__42LeetCode__LongestCommon__Prefix : str=["hello", "heabc", "hewww"] : "he"AC__014Longest__CommonPrefix__43class__Solution(object):def__longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype:str__"""if__not strs:return__""longest__= strs[0]for__iin__range(len(strs[0])):for__strin__strs:if__len(str) <=i__or strs[0][i] != str[i]:return__strs[0][:i]return__strs[0]if____name__ == "__main__":assert__Solution().longestCommonPrefix(["hello", "heabc", "he ll"]) == "he"Github__(https://github.com/gavinfish/LeetCode-Python) 014Longest__CommonPrefix__44LeetCode__3Sum (a<=b<=c) : nums=[-1, 0, 1, 2, -1, -4] : [[-1, -1, 2], [-1, 0, 1]] 0 0a__-aAC__015 3Sum 45class__Solution(object):def__threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ #Sorted__arraycan__savea__lotof__time nums.sort()result__= []i__= 0while__i < len(nums) - 2:j__=i__+ 1k__= len(nums) - 1while__j < k:l__= [nums[i], nums[j], nums[k]]if__sum(l) == 0: result.append(l)j__+= 1k__-= 1 #Ignore__repeatnumbers__whilej__<k__and nums[j] == nums[j - 1]:j__+= 1while__j <k__and nums[k] == nums[k + 1]:k__-= 1elif__sum(l) > 0:k__-= 1 else:j__+= 1i__+= 1 #Ignore__repeatnumbers__whilei__< len(nums) - 2and__nums[i] == nums[i - 1]:i__+= 1return__resultif____name__ == "__main__":assert__Solution().threeSum([-1, 0, 1, 2, -1, -4]) == [[-1, -1 , 2], [-1, 0, 1]] 015 3Sum 46Github__(https://github.com/gavinfish/LeetCode-Python) 015 3Sum 47LeetCode__3SumClosest__: nums=[1, 1, 1, 1], target=-100 : 3 3SumAC__016 3SumClosest__48class__Solution(object):def__threeSumClosest(self, nums, target): """ :type nums: List[int] :type target:int__:rtype:int__""" nums.sort()i__= 0result__= 0 #Init__thedistance__betweenresult__andtarget__witha__very__largenumber__distance = pow(2, 32) - 1for__iin__range(len(nums)):j__=i__+ 1k__= len(nums) - 1while__j < k:l__= [nums[i], nums[j], nums[k]]if__sum(l) == target:return__targetif__abs(sum(l) - target) < distance:result__= sum(l)distance__= abs(sum(l) - target)elif__sum(l) > target:k__-= 1 else:j__+= 1return__resultif____name__ == "__main__":assert__Solution().threeSumClosest([1, 1, 1, 1], -100) == 3Github__(https://github.com/gavinfish/LeetCode-Python) 016 3SumClosest__49LeetCode__LetterCombinations__ofa__PhoneNumber__2 "abc" : digits="23" : ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"] 017Letter__Combinationsof__aPhone__Number 50AC__class Solution(object): digit2letters = { '2': "abc", '3': "def", '4': "ghi", '5': "jkl", '6': "mno", '7': "pqrs", '8': "tuv", '9': "wxyz", }def__letterCombinations(self, digits): """ :type digits:str__:rtype: List[str] """if__not digits:return__[]result__= [] self.dfs(digits, "", result)return__resultdef__dfs(self, digits, current, result):if__not digits: result.append(current)return__forc__in self.digit2letters[digits[0]]: self.dfs(digits[1:],current__+ c, result)if____name__ == "__main__":assert__Solution().letterCombinations("23") == ["ad", "ae", " af", "bd", "be", "bf", "cd", "ce", "cf"] 017Letter__Combinationsof__aPhone__Number 51Github__(https://github.com/gavinfish/LeetCode-Python) 017Letter__Combinationsof__aPhone__Number 52LeetCode__4Sum (a<=b<=c) : nums=[1, 0, -1, 0, -2, 2] : [[-1, 0, 0, 1], [-2, 0, 0, 2], [-2, -1, 1, 2]] 3Sum -AC__018 4Sum 53class__Solution(object):def__fourSum(self, nums, target): """ :type nums: List[int] :type target:int__:rtype: List[List[int]] """if__len(nums) < 4:return__[]result__= set()sumsIndexes__= {} #Get__alltwo__elements'sum__andindexes__mapfor__iin__range(len(nums)):for__jin__range(i + 1, len(nums)):if__nums[i] + nums[j]in__sumsIndexes: sumsIndexes[nums[i] + nums[j]].append((i, j) ) else: sumsIndexes[nums[i] + nums[j]] = [(i, j)]for__iin__range(len(nums)):for__jin__range(i + 1, len(nums)):sumNeeded__=target__- (nums[i] + nums[j])if__sumNeededin__sumsIndexes:for__indexin__sumsIndexes[sumNeeded]: #Ingore__repeatingresults__if index[0] > j: result.add(tuple(sorted([nums[i],nu__ms[j], nums[index[0]], nums[index[1]]]))) #Format__resultwith__list[list]pattern__result = [list(l)for__lin__result]return__resultif____name__ == "__main__":assert__Solution().fourSum([1, 0, -1, 0, -2, 2], 0) == [[-1, 0 , 0, 1], [-2, 0, 0, 2], [-2, -1, 1, 2]] 018 4Sum 54Github__(https://github.com/gavinfish/LeetCode-Python) 018 4Sum 55LeetCode__RemoveNth__NodeFrom__Endof__Listn__n :list__= 1->2->3->4->5,n__= 2. : 1->2->3->5n__AC #Definition__for singly-linked list.class__ListNode(object):def____init__(self, x): self.val =x__self.next =None__#Define__thisto__checkif__itworks__welldef__myPrint(self): 019Remove__NthNode__FromEnd__ofList__56 print(self.val)if__self.next: self.next.myPrint()class__Solution(object):def__removeNthFromEnd(self, head, n): """ :type head:ListNode__:type n:int__:rtype:ListNode__"""if__not head:return__headdummy__= ListNode(-1) dummy.next=headprev__=dummy__cur =dummy__whileprev__andn__>= 0:prev__= prev.nextn__-= 1while__prev:prev__= prev.nextcur__= cur.next cur.next = cur.next.nextreturn__dummy.nextif____name__ == "__main__": n5 = ListNode(5) n4 = ListNode(4) n3 = ListNode(3) n2 = ListNode(2) n1 = ListNode(1) n1.next = n2 n2.next = n3 n3.next = n4 n4.next = n5result__= Solution().removeNthFromEnd(n1, 5) result.myPrint() 019Remove__NthNode__FromEnd__ofList__57Github__(https://github.com/gavinfish/LeetCode-Python) 019Remove__NthNode__FromEnd__ofList__58LeetCode__ValidParentheses__"(",")","[","]","{","}" "([)]" : s="(){}" :True__: s="(){}[" :False__"]]]" "[[["AC__020Valid__Parentheses 59class__Solution(object):def__isValid(self, s): """ :type s:str__:rtype:bool__""" #Valid__strmust__beeven__if len(s) % 2 == 1:return__Falsestack__= []left__= ("(", "[", "{")right__= (")", "]", "}") zip(left,right)for__vin__s:if__vin__left: stack.append(v) else:if__not stack:return__Falsep__= stack.pop()if__left.index(p) != right.index(v):return__Falsereturn__len(stack) == 0if____name__ == "__main__":assert__Solution().isValid("({}){}") ==True__assert Solution().isValid("({)}") ==False__assert Solution().isValid("}}}") ==False__assert Solution().isValid("(((") ==False__Github (https://github.com/gavinfish/LeetCode-Python) 020Valid__Parentheses 60LeetCode__MergeTwo__SortedLists__: l1 = 1->2->4, l2 = 3 : 1->2->3->4 l1 l2AC__021Merge__TwoSorted__Lists 61 #Definition__for singly-linked list.class__ListNode(object):def____init__(self, x): self.val =x__self.next =None__class Solution(object):def__mergeTwoLists(self, l1, l2): """ :type l1:ListNode__:type l2:ListNode__:rtype:ListNode__"""temp__= ListNode(-1)head__=temp__while l1and__l2:if__l1.val > l2.val: temp.next = l2 l2 = l2.next else: temp.next = l1 l1 = l1.nexttemp__= temp.nextif__l1: temp.next = l1 else: temp.next = l2return__head.nextif____name__ == "__main__":assert__Solution().mergeTwoLists(ListNode(1), ListNode(2)).val__== 1Github__(https://github.com/gavinfish/LeetCode-Python) 021Merge__TwoSorted__Lists 62 021Merge__TwoSorted__Lists 63LeetCode__GenerateParentheses__n "()" :n__= 3 : ['((()))', '(()())', '(())()', '()(())', '()()()'] ")*"AC__022Generate__Parentheses 64class__Solution(object):def__generateParenthesis(self, n): """ :type n:int__:rtype: List[str] """result__= [] self.generate(n, n, "", result)return__resultdef__generate(self, left, right, str, result):if__left == 0and__right == 0: result.append(str)return__ifleft__> 0: self.generate(left - 1, right,str__+ "(", result)if__right > left: self.generate(left,right__- 1,str__+ ")", result)if____name__ == "__main__":assert__(Solution().generateParenthesis(3)) == ['((()))', '(( )())', '(())()', '()(())', '()()()']Github__(https://github.com/gavinfish/LeetCode-Python) 022Generate__Parentheses 65LeetCode__Mergek__SortedLists__kPython__heapq :lists__= [[1->2>10],[3->9],[5->6]] : 1->2->3->5->6->9->10Merge__TwoLists__kPython__heapqAC__023Merge__kSorted__Lists 66import__heapq #Definition__for singly-linked list.class__ListNode(object):def____init__(self, x): self.val =x__self.next =None__class Solution(object):def__mergeKLists(self, lists): """ :type lists: List[ListNode] :rtype:ListNode__"""heap__= []for__nodein__lists:if__node: heapq.heappush(heap, (node.val, node))temp__= ListNode(-1)head__=temp__while heap:smallestNode__= heapq.heappop(heap)[1] temp.next =smallestNode__temp = temp.nextif__smallestNode.next: heapq.heappush(heap, (smallestNode.next.val,sma__llestNode.next))return__head.nextGithub__(https://github.com/gavinfish/LeetCode-Python) 023Merge__kSorted__Lists 67LeetCode__SwapNodes__inPairs__:head__= 1->2->3->4 : 2->1->4->3 A->B->C->DB__C 1.A__C 2.B__D 3.C__BAC__024Swap__Nodesin__Pairs 68 #Definition__for singly-linked list.class__ListNode(object):def____init__(self, x): self.val =x__self.next =None__class Solution(object):def__swapPairs(self, head): """ :type head:ListNode__:rtype:ListNode__"""prev__= ListNode(-1) prev.next =head__temp =prev__while temp.nextand__temp.next.next: node1 = temp.next node2 = temp.next.next temp.next = node2 node1.next = node2.next node2.next = node1temp__= temp.next.nextreturn__prev.nextGithub__(https://github.com/gavinfish/LeetCode-Python) 024Swap__Nodesin__Pairs 69LeetCode__ReverseNodes__in k-Groupk__k :head__= 1->2->3->4->5,k__= 2 : 2->1->4->3->5 :head__= 1->2->3->4->5,k__= 3 : 3->2->1->4->5Swap__Nodesin__Pairsk__A->B->C->D->EBCD__1. C->B 2. D->C 3. B->E 4. A->D 5.B__k 1 2 3 4AC__#Definition__for singly-linked list.class__ListNode(object): 025Reverse__Nodesin__k-Group 70def____init__(self, x): self.val =x__self.next =None__class Solution(object):def__reverseKGroup(self, head, k): """ :type head:ListNode__:type k:int__:rtype:ListNode__"""if__nothead__ork__<= 1:return__headdummy__= ListNode(-1) dummy.next =head__temp =dummy__while temp:temp__= self.reverseNextK(temp, k)return__dummy.nextdef__reverseNextK(self, head, k): #Check__ifthere__arek__nodesleft__temp =head__fori__in range(k):if__not temp.next:return__Nonetemp__= temp.next #The__lastnode__whenthe__knodes__reversednode__= head.nextprev__=head__curr = head.next #Reverse__knodes__fori__in range(k):nextNode__= curr.nex curr.next =prev__prev =curr__curr =nextNode__#Connect__withhead__andtail__025Reverse__Nodesin__k-Group 71 node.next =curr__head.next =prev__returnnode__Github (https://github.com/gavinfish/LeetCode-Python) 025Reverse__Nodesin__k-Group 72LeetCode__RemoveDuplicates__fromSorted__Array :nums__= [1, 1, 2] : 2index__startindex__indexstart__indexAC__026Remove__Duplicatesfrom__SortedArray__73class__Solution(object):def__removeDuplicates(self, nums): """ :type nums: List[int] :rtype:int__"""if__not nums:return__0 #The__indexwhere__thecharacter__needsto__beplaced__index = 1 #The__indexof__repeatingcharacters__start = 0for__iin__range(1, len(nums)):if__nums[start] != nums[i]: nums[index] = nums[i]index__+= 1start__=i__returnindex__if__name____== "__main__":assert__Solution().removeDuplicates([1, 1, 2]) == 2Github__(https://github.com/gavinfish/LeetCode-Python) 026Remove__Duplicatesfrom__SortedArray__74LeetCode__RemoveElement__:nums__[1, 2, 3, 4, 3, 2, 1]val__= 1 : 5val__valAC__027Remove__Element 75class__Solution(object):def__removeElement(self, nums, val): """ :type nums: List[int] :type val:int__:rtype:int__"""left__= 0right__= len(nums) - 1while__left <= right:while__left <=right__and nums[left] != val:left__+= 1while__left <=right__and nums[right] == val:right__-= 1if__left < right: nums[left] = nums[right]left__+= 1right__-= 1return__right + 1if____name__ == "__main__":assert__Solution().removeElement([1, 2, 3, 4, 3, 2, 1], 1) == 5assert__Solution().removeElement([2], 3) == 1Github__(https://github.com/gavinfish/LeetCode-Python) 027Remove__Element 76LeetCode__Implement strStr() strStr()ABAB__-1 0 :haystack__= "abc",needle__= "bc" : 1 :haystack__= "abc",needle__= "gd" : -1KMP__Sunday "abcdefg" "ef"abcdefg__ef "c" +1abcdefg__ef "f" "ef" 028Implement__strStr() 77abcdefg__efAC__028Implement__strStr() 78class__Solution(object):def__strStr(self, haystack, needle): """ :type haystack:str__:type needle:str__:rtype:int__"""if__not needle:return__0if__not haystack:return__-1i__= 0needleLength__= len(needle)while__i < len(haystack):a__= haystack[i:i + needleLength]if__haystack[i:i + needleLength] == needle:return__i else:index__= 0 try:index__= needle.rindex(haystack[i +needleLen__gth])except__Exception:i__+=needleLength__+ 1i__+= needleLength-indexreturn__-1if____name__ == "__main__":assert__Solution().strStr("abcdefg", "ab") == 0assert__Solution().strStr("abcdefg", "bc") == 1assert__Solution().strStr("abcdefg", "cd") == 2assert__Solution().strStr("abcdefg", "fg") == 5assert__Solution().strStr("abcdefg", "bcf") == -1Github__(https://github.com/gavinfish/LeetCode-Python) 028Implement__strStr() 79 028Implement__strStr() 80LeetCode__DivideTwo__Integersint__intMAX_INT__:dividend__= 5,divisor__= -1 : -5current__currentmin__AC 029Divide__TwoIntegers__81class__Solution(object):def__divide(self, dividend, divisor): """ :type dividend:int__:type divisor:int__:rtype:int__"""MAX_INT__= 2147483647sign__= 1if__dividend >= 0and__divisor < 0or__dividend <= 0and__divisor__> 0:sign__= -1dividend__= abs(dividend)divisor__= abs(divisor)result__= 0current__=divisor__currentResult = 1while__current <= dividend:current__<<= 1currentResult__<<= 1while__divisor <= dividend:current__>>= 1currentResult__>>= 1if__current <= dividend:dividend__-=current__result +=currentResult__return min(sign * result, MAX_INT)if____name__ == "__main__":assert__Solution().divide(5, -1) == -5assert__Solution().divide(10, 2) == 5Github__(https://github.com/gavinfish/LeetCode-Python) 029Divide__TwoIntegers__82 029Divide__TwoIntegers__83LeetCode__Substringwith__Concatenationof__AllWords__wordswords__:s__= "barfoothefoobarman",words__= ["foo", "bar"] : [0, 9]words__dict "barfoothefoobarman" 3 'bar' | 'foo' | 'the' | 'foo' | 'bar' | 'man' 'arf' | 'oot' | 'hef' | 'oob' | 'arm' 'rfo' | 'oth' | 'efo' | 'oba' | 'rma'dict__wordsdict__words 030Substring__withConcatenation__ofAll__Words 84AC__class Solution(object):def__findSubstring(self, s, words): """ :type s:str__:type words: List[str] :rtype: List[int] """s_length__= len(s)word_num__= len(words)word_length__= len(words[0])words_length__=word_num__*word_length__result = []words_dict__= {}for__wordin__words: words_dict[word] = words_dict[word] + 1if__wordin__words_dict__else 1for__iin__range(word_length):left__=i__right =i__curr_dict = {}while__right +word_length__<= s_length:word__= s[right:right + word_length]right__+=word_length__ifword__in words_dict: curr_dict[word] = curr_dict[word] + 1if__word__incurr_dict__else 1while__curr_dict[word] > words_dict[word]: curr_dict[s[left:left + word_length]] -= 1left__+=word_length__ifright__-left__== words_length: result.append(left) else: curr_dict.clear()left__=right__returnresult__030Substring__withConcatenation__ofAll__Words 85if____name__ == "__main__":assert__Solution().findSubstring("barfoothefoobarman", ["foo" , "bar"]) == [0, 9]Github__(https://github.com/gavinfish/LeetCode-Python) 030Substring__withConcatenation__ofAll__Words 86LeetCode__NextPermutation__: [1,2,3] : [1,3,2] : [3,2,1] : [1,2,3] [1,7,3,4,1] 173421 421 3 3 3 4 3 4 174321 3AC__031Next__Permutation 87class__Solution(object):def__nextPermutation(self, nums): """ :type nums: List[int] :rtype:void__Donot__return anything,modify__nums in-place__instead. """length__= len(nums)targetIndex__= 0changeIndex__= 0for__iin__range(length - 1, 0, -1):if__nums[i] > nums[i - 1]:targetIndex__=i__- 1break__fori__in range(length - 1, -1, -1):if__nums[i] > nums[targetIndex]:changeIndex__=i__break nums[targetIndex], nums[changeIndex] = nums[changeIndex] , nums[targetIndex]if__targetIndex ==changeIndex__== 0: nums.reverse() else: nums[targetIndex + 1:] = reversed(nums[targetIndex + 1:])Github__(https://github.com/gavinfish/LeetCode-Python) 031Next__Permutation 88LeetCode__LongestValid__Parentheses "(" ")" :s__= "(()" : 2 :s__= ")()())" : 4 dp[i]i__dp dp[0]=0 : ) ( ) ( ( ) ) ) 0 1 2 3 4 5 6 7 7 6 3-6 3 7 6 5 4- 5 3 6 dp[i]+2dp__3 6 1 2 6AC__032Longest__ValidParentheses__89class__Solution(object):def__longestValidParentheses(self, s): """ :type s:str__:rtype:int__"""if__not s:return__0length__= len(s)dp__= [0for____in__range(length)]for__iin__range(1, length):if__s[i] == ")":j__=i__- 1 - dp[i - 1]if__j >= 0and__s[j] == "(": dp[i] = dp[i - 1] + 2if__j - 1 >= 0: dp[i] += dp[j - 1]return__max(dp)if____name__ == "__main__":assert__Solution().longestValidParentheses("(()))())(") == 4assert__Solution().longestValidParentheses("(()") == 2assert__Solution().longestValidParentheses(")()())") == 4Github__(https://github.com/gavinfish/LeetCode-Python) 032Longest__ValidParentheses__90LeetCode__Searchin__RotatedSorted__Array [0,1,2,3,4,5] 3 [3,4,5,0,1,2] -1 :nums__= [4, 5, 6, 7, 0, 1, 2],target__= 6 : 2 :nums__= [4, 5, 6, 7, 0, 1, 2],target__= 3 : -1 / / / / / / / [3,1] 3 033Search__inRotated__SortedArray__91 1AC__033Search__inRotated__SortedArray__92class__Solution(object):def__search(self, nums, target): """ :type nums: List[int] :type target:int__:rtype:int__"""left__= 0right__= len(nums) - 1while__left <= right:mid__=left__+ (right - left) // 2if__nums[mid] == target:return__midif__nums[mid] > nums[left]:if__nums[left] <=target__<= nums[mid]:right__=mid__- 1 else:left__=mid__+ 1elif__nums[mid] < nums[left]:if__nums[mid] <=target__<= nums[right]:left__=mid__+ 1 else:right__=mid__- 1 else:left__+= 1return__-1if____name__ == "__main__":assert__Solution().search([4, 5, 6, 7, 0, 1, 2], 4) == 0assert__Solution().search([4, 5, 6, 7, 0, 1, 2], 7) == 3assert__Solution().search([4, 5, 6, 7, 0, 1, 2], 0) == 4assert__Solution().search([4, 5, 6, 7, 0, 1, 2], 2) == 6assert__Solution().search([3, 1], 3) == 0assert__Solution().search([3, 1], 1) == 1Github__(https://github.com/gavinfish/LeetCode-Python) 033Search__inRotated__SortedArray__93 033Search__inRotated__SortedArray__94LeetCode__Searchfor__aRange__[-1, -1] log(n) :nums__= [5, 7, 7, 8, 8, 10],target__= 8 : [3, 4] :nums__= [5, 7, 7, 8, 8, 10],target__= 6 : [-1, -1]AC__class Solution(object):def__searchRange(self, nums, target): """ :type nums: List[int] :type target:int__:rtype: List[int] """result__= []length__= len(nums) 034Search__fora__Range 95start__= 0end__=length__whilestart__< end:mid__= (start + end) // 2if__nums[mid] ==target__and (mid == 0or__nums[mid - 1 ] != target): result.append(mid)break__if nums[mid] < target:start__=mid__+ 1 else:end__=mid__ifnot__result:return__[-1, -1]end__=length__whilestart__< end:mid__= (start + end) // 2if__nums[mid] ==target__and (mid ==length__- 1or__num s[mid + 1] != target): result.append(mid)break__if nums[mid] <= target:start__=mid__+ 1 else:end__=mid__returnresult__if__name____== "__main__":assert__Solution().searchRange([5, 7, 7, 8, 8, 10], 8) == [3, 4]assert__Solution().searchRange([5, 7, 7, 8, 8, 10], 5) == [0, 0]assert__Solution().searchRange([5, 7, 7, 8, 8, 10], 7) == [1, 2]assert__Solution().searchRange([5, 7, 7, 8, 8, 10], 10) == [5 , 5] 034Search__fora__Range 96Github__(https://github.com/gavinfish/LeetCode-Python) 034Search__fora__Range 97LeetCode__SearchInsert__Position :nums__= [1, 3, 5, 6],target__= 5 : 2 :nums__= [1, 3, 5, 6],target__= 2 : 1AC__035Search__InsertPosition__98class__Solution(object):def__searchInsert(self, nums, target): """ :type nums: List[int] :type target:int__:rtype:int__"""length__= len(nums)start__= 0end__=length__whilestart__< end:mid__= (start + end) // 2if__nums[mid] ==target__or (nums[mid] >target__and (mid == 0or__nums[mid - 1] < target)):return__midif__mid ==length__- 1and__nums[mid] < target:return__mid + 1if__nums[mid] < target:start__=mid__+ 1 else:end__=mid__if__name____== "__main__":assert__Solution().searchInsert([1, 3, 5, 6], 5) == 2assert__Solution().searchInsert([1, 3, 5, 6], 2) == 1assert__Solution().searchInsert([1, 3, 5, 6], 7) == 4assert__Solution().searchInsert([1, 3, 5, 6], 0) == 0Github__(https://github.com/gavinfish/LeetCode-Python) 035Search__InsertPosition__99LeetCode__ValidSudoku__"." : board= ["..4...63.",".........","5......9.","...56....","4.3.....1","...7.....","...5.....",".........","........."] :false__board[i/3*3+j/3][i%3*3+j%3]AC__036Valid__Sudoku 100class__Solution(object):def__isValidSudoku(self, board): """ :type board: List[List[str]] :rtype:bool__"""point__= "."for__iin__range(9):row__= []column__= []square__= []for__jin__range(9):element__= board[i][j]if__element != point:if__elementin__row:return__False else: row.append(element)element__= board[j][i]if__element != point:if__elementin__column:return__False else: column.append(element)element__= board[i // 3 * 3 +j__// 3][i % 3 * 3 +j__% 3]if__element != point:if__elementin__square:return__False else: square.append(element)return__TrueGithub__(https://github.com/gavinfish/LeetCode-Python) 036Valid__Sudoku 101 036Valid__Sudoku 102LeetCode__SudokuSolver__: : 037Sudoku__Solver 103Valid__SudokuAC__class Solution(object):def__solveSudoku(self, board): """ :type board: List[List[str]] :rtype:void__Donot__return anything,modify__board in-place__instead. """for__rowin__range(9): board[row] = list(board[row]) self.recursive(0, 0, board)for__rowin__range(9): board[row] = "".join(board[row])def__recursive(self, i, j, board):if__j >= 9:return__self.recursive(i + 1, 0, board)if__i == 9:return__Trueif__board[i][j] == ".":for__numin__range(1, 10):num_str__= str(num) 037Sudoku__Solver 104if__all([board[i][col] !=num_str__forcol__in range(9)])and__all([board[row][j] !=num___strfor__rowin__range(9)])and__all( [board[i // 3 * 3 +count__// 3][j // 3 * 3 +count__% 3] !=num_str__forcount__in range(9)]): board[i][j] =num_str__ifnot__self.recursive(i,j__+ 1, board): board[i][j] = "." else:return__True else:return__self.recursive(i,j__+ 1, board)return__Falseif____name__ == "__main__":sudoku__= ["..9748...", "7........", ".2.1.9...", "..7...24." , ".64.1.59.", ".98...3..", "...8.3.2.", "........6", "...2759.."] Solution().solveSudoku(sudoku)assert__sudoku == ['519748632', '783652419', '426139875', '35 7986241', '264317598', '198524367', '975863124', '832491756', '641275983']Github__(https://github.com/gavinfish/LeetCode-Python) 037Sudoku__Solver 105LeetCode__Countand__Say 2 1 2 12 12 1112 1n__5 1, 11, 21, 1211, 111221, ... :n__= 5 : 111221AC__038Count__andSay__106class__Solution(object):def__countAndSay(self, n): """ :type n:int__:rtype:str__"""result__= "1"for____in__range(1, n):result__= self.getNext(result)return__resultdef__getNext(self, s):result__= []start__= 0while__start < len(s):curr__=start__+ 1while__curr < len(s)and__s[start] == s[curr]:curr__+= 1 result.extend((str(curr - start), s[start]))start__=curr__return "".join(result)if____name__ == "__main__":assert__Solution().countAndSay(4) == "1211"assert__Solution().countAndSay(5) == "111221"Github__(https://github.com/gavinfish/LeetCode-Python) 038Count__andSay__107LeetCode__CombinationSum__:candidates__= [2, 3, 6, 7],target__= 7 : [[2, 2, 3], [7]]AC__039Combination__Sum 108class__Solution(object):def__combinationSum(self, candidates, target): """ :type candidates: List[int] :type target:int__:rtype: List[List[int]] """if__not candidates:return__[] candidates.sort()result__= [] self.combination(candidates, target, [], result)return__resultdef__combination(self, candidates, target, current, result):s__= sum(current)if__currentelse__0if__s > target:return__elifs__== target: result.append(current)return__else:for__i,v__in enumerate(candidates): self.combination(candidates[i:], target,current__+ [v], result)if____name__ == "__main__":assert__Solution().combinationSum([2, 3, 6, 7], 7) == [[2, 2, 3], [7]]Github__(https://github.com/gavinfish/LeetCode-Python) 039Combination__Sum 109LeetCode__CombinationSum__II :candidates__= [10, 1, 2, 7, 6, 1, 5],target__= 8 : [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]Combination__SumCombination__SumAC__040Combination__SumII__110class__Solution(object):def__combinationSum2(self, candidates, target): """ :type candidates: List[int] :type target:int__:rtype: List[List[int]] """if__not candidates:return__[] candidates.sort()result__= [] self.combination(candidates, target, [], result)return__resultdef__combination(self, candidates, target, current, result):s__= sum(current)if__currentelse__0if__s > target:return__elifs__== target: result.append(current)return__else:i__= 0while__i < len(candidates): self.combination(candidates[i + 1:], target,cur__rent + [candidates[i]], result) #ignore__repeatingelements__whilei__+ 1 < len(candidates)and__candidates[i] == candidates[i + 1]:i__+= 1i__+= 1if____name__ == "__main__":assert__Solution().combinationSum2([10, 1, 2, 7, 6, 1, 5], 8) == [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]Github__(https://github.com/gavinfish/LeetCode-Python) 040Combination__SumII__111 040Combination__SumII__112LeetCode__FirstMissing__Positive O(n) :nums__= [1, 2, 0] : 3 :nums__= [3,4,-1,1] : 2 [1,2,0] [3,4,-1,1] [1,-1,3,4] nums[i]!=i+1 1AC__041First__MissingPositive__113class__Solution(object):def__firstMissingPositive(self, nums): """ :type nums: List[int] :rtype:int__"""if__not nums:return__1i__= 0length__= len(nums)while__i < length:current__= nums[i]if__current <= 0or__current >length__or nums[current - 1] == current:i__+= 1 else: nums[current - 1], nums[i] = nums[i], nums[current__- 1]for__iin__range(length):if__nums[i] !=i__+ 1:return__i + 1return__length + 1if____name__ == "__main__":assert__Solution().firstMissingPositive([1, 2, 0]) == 3assert__Solution().firstMissingPositive([1, 2, 3]) == 4assert__Solution().firstMissingPositive([3, 4, -1, 1]) == 2Github__(https://github.com/gavinfish/LeetCode-Python) 041First__MissingPositive__114LeetCode__TrappingRain__Water :height__= [0,1,0,2,1,0,1,3,2,1,2,1] : 6Container__WithMost__Water 042Trapping__RainWater__115AC__class Solution(object):def__trap(self, height): """ :type height: List[int] :rtype:int__"""if__not height:return__0length__= len(height)maxh__= [0for____in__range(length)]h__= height[length - 1]for__iin__range(length - 2, -1, -1): maxh[i] =h__h = max(h, height[i])h__= height[0]result__= 0for__iin__range(1,length__- 1):h__= max(h, height[i])result__+= max(0, min(h, maxh[i]) - height[i])return__resultif____name__ == "__main__":assert__Solution().trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6Github__(https://github.com/gavinfish/LeetCode-Python) 042Trapping__RainWater__116LeetCode__MultiplyStrings__: num1 = "123", num2 = "20" : "2460" mnm+n 9 0 123 456 1 6 2 5 3 4 0 043Multiply__Strings 117 123*456 100 400 20 50 3 6 [3*6, 2*6+3*5, 1*6+2*5+3*4, 2*4+1*5, 1*4, 0] [18, 27, 28, 13, 4, 0] [8, 27+1, 28, 13, 4, 0] [8, 8, 28+2, 13, 4, 0] [8, 8, 0, 13+3, 4, 0] [8, 8, 0, 6, 5, 0] "880650"-->"056088" "56088"AC__043Multiply__Strings 118class__Solution(object):def__multiply(self, num1, num2): """ :type num1:str__:type num2:str__:rtype:str__""" num1 = num1[::-1] num2 = num2[::-1] length1 = len(num1) length2 = len(num2)temp__= [0for____in__range(length1 + length2)] #Do__multiplyfor__iin__range(length1):for__jin__range(length2): temp[i + j] += int(num1[i]) * int(num2[j])carry__= 0digits__= [] #Do__plusfor__numin__temp:s__=carry__+num__carry =s__// 10 digits.append(str(s % 10))result__= "".join(digits)[::-1] #Remove__thesurplus__zerosub_index__= 0for__iin__range(length1 + length2 - 1):if__result[i] == "0":sub_index__+= 1 else:break__result = result[sub_index:]return__resultif____name__ == "__main__":assert__Solution().multiply("120", "20000") == 2400000assert__Solution().multiply("0", "3421") == 0 043Multiply__Strings 119Github__(https://github.com/gavinfish/LeetCode-Python) 043Multiply__Strings 120LeetCode__WildcardMatching__"?" "*" :s__= "abc",p__= "a*b*e" :False__RegularExpression__Matching ( "?" ) "*" "*" 0 "*" "*" "*"AC__class Solution(object):def__isMatch(self, s, p): 044Wildcard__Matching 121 """ :type s:str__:type p:str__:rtype:bool__""" p_index, s_index, last_s_index,last_p_index__= 0, 0, -1, -1while__s_index < len(s): #Normal__matchincluding__'?'if__p_index < len(p)and__(s[s_index] == p[p_index]or__p[p_index] == '?'):s_index__+= 1p_index__+= 1 #Match__with '*'elif__p_index < len(p)and__p[p_index] == '*':p_index__+= 1last_s_index__=s_index__last_p_index =p_index__#Not__match,but__thereis__a '*'before__eliflast_p_index__!= -1:last_s_index__+= 1s_index__=last_s_index__p_index =last_p_index__#Not__matchand__thereis__no '*'before__else:return__False #Check__ifthere__isstill__characterexcept__'*'in__thepa__tternwhile__p_index < len(p)and__p[p_index] == '*':p_index__+= 1 #If__finishscanning__bothstring__and pattern,then__itma__tcheswell__returnp_index__== len(p)if____name__ == "__main__":assert__Solution().isMatch("aa", "a") ==False__assert Solution().isMatch("aa", "aa") ==True__assert Solution().isMatch("aaa", "aa") ==False__assert Solution().isMatch("aa", "*") ==True__044Wildcard__Matching 122assert__Solution().isMatch("aa", "a*") ==True__assert Solution().isMatch("ab", "?*") ==True__assert Solution().isMatch("aab", "c*a*b") ==False__Github (https://github.com/gavinfish/LeetCode-Python) 044Wildcard__Matching 123LeetCode__JumpGame__II :nums__= [2, 3, 1, 1, 4] : 2Jump__Gamereach__nlongest__longestAC__045Jump__GameII__124class__Solution(object):def__jump(self, nums): """ :type nums: List[int] :rtype:int__"""length__= len(nums)counter__= 0longest__= 0reach__= 0for__iin__range(length):if__longest < i:counter__+= 1longest__=reach__reach = max(reach, nums[i] + i)return__counterif____name__ == "__main__":assert__Solution().jump([2, 3, 1, 1, 4]) == 2Github__(https://github.com/gavinfish/LeetCode-Python) 045Jump__GameII__125LeetCode__Permutaions :nums__= [1, 2, 3] : [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]current__AC 046Permutations__126class__Solution(object):def__permute(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """result__= [] self.get_permute([], nums, result)return__resultdef__get_permute(self, current, num, result):if__not num: result.append(current + [])return__for i,v__in enumerate(num): current.append(num[i]) self.get_permute(current, num[:i] + num[i + 1:],res__ult) current.pop()if____name__ == "__main__":assert__Solution().permute([1, 2, 3]) == [[1, 2, 3], [1, 3, 2 ], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]Github__(https://github.com/gavinfish/LeetCode-Python) 046Permutations__127LeetCode__PermutaionsII__:nums__= [1, 2, 1] : [[1, 1, 2], [1, 2, 1], [2, 1, 1]]Permutations__AC 047Permutations__II 128class__Solution(object):def__permuteUnique(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """result__= [] nums.sort() self.get_permute([], nums, result)return__resultdef__get_permute(self, current, num, result):if__not num: result.append(current + [])return__for i,v__in enumerate(num):if__i - 1 >= 0and__num[i] == num[i - 1]:continue__current.append(num[i]) self.get_permute(current, num[:i] + num[i + 1:],res__ult) current.pop()if____name__ == "__main__":assert__Solution().permuteUnique([1, 2, 1]) == [[1, 1, 2], [1 , 2, 1], [2, 1, 1]]Github__(https://github.com/gavinfish/LeetCode-Python) 047Permutations__II 129LeetCode__RotateImage__90 :matrix__= [[1, 2, 3], [8, 9, 4], [7, 6, 5]] : [[7, 8, 1], [6, 9, 2], [5, 4, 3]] 90 1 2 3 5 4 3 7 8 1 8 9 4 -> 6 9 2 -> 6 9 2 7 6 5 7 8 1 5 4 3AC__048Rotate__Image 130class__Solution(object):def__rotate(self, matrix): """ :type matrix: List[List[int]] :rtype:void__Donot__return anything,modify__matrix in-place__instead. """n__= len(matrix)for__rowin__range(n):for__columnin__range(n - row): matrix[row][column], matrix[n - 1 - column][n - 1 - row] = matrix[n - 1 - column][n - 1 - row], \ matrix[row][column]for__rowin__range(n // 2):for__columnin__range(n): matrix[row][column], matrix[n - 1 - row][column] = matrix[n - 1 - row][column], matrix[row][column] #No__need,just__totest__returnmatrix__if__name____== "__main__":assert__Solution().rotate([[1, 2, 3], [8, 9, 4], [7, 6, 5]]) == [[7, 8, 1], [6, 9, 2], [5, 4, 3]]Github__(https://github.com/gavinfish/LeetCode-Python) 048Rotate__Image 131LeetCode__GroupAnagrams__:strs__= ["eat", "tea", "tan", "ate", "nat", "bat"] : [ ["ate", "eat","tea"], ["nat","tan"], ["bat"] ]AC__049Group__Anagrams 132class__Solution(object):def__groupAnagrams(self, strs): """ :type strs: List[str] :rtype: List[List[str]] """map__= {}for__i,v__in enumerate(strs):target__= "".join(sorted(v))if__targetnot__in map: map[target]=[v] else: map[target].append(v)result__= []for__valuein__map.values():result__+= [sorted(value)]return__resultif____name__ == "__main__":assert__Solution().groupAnagrams(["eat", "tea", "tan", "ate", "nat", "bat"]) == [['nat', 'tan'], ['bat'], ['ate', 'eat', 'tea']]Github__(https://github.com/gavinfish/LeetCode-Python) 049Group__Anagrams 133LeetCode__Pow(x, n)x__nn__:x__= 2,n__= -1 : 0.5 :x__= 2.1,n__= 2 : 4.41n__x (n-1) 2**8 ( 2 8 ) 7 (2**2)**4 - > ((2**2)**2)**2 3n__xxxn 2n__AC 050 Pow(X, n) 134class__Solution(object):def__myPow(self, x, n): """ :type x:float__:type n:int__:rtype:float__"""flag__= 1if__n >= 0else__-1result__= 1n__= abs(n)while__n > 0:if__n & 1 == 1:result__*=x__n >>= 1x__*=x__ifflag__< 0:result__= 1 /result__returnresult__if__name____== "__main__":assert__Solution().myPow(2, -1) == 0.5assert__Solution().myPow(2.1, 2) == 4.41Github__(https://github.com/gavinfish/LeetCode-Python) 050 Pow(X, n) 135LeetCode__N-QueensPython__"Q" "." :n__= 4 : [ ['.Q..', '...Q', 'Q...', '..Q.'], ['..Q.', 'Q...', '...Q', '.Q..']] 051 N-Queens 136AC__051 N-Queens 137class__Solution(object):def__solveNQueens(self, n): """ :type n:int__:rtype: List[List[str]] """ self.col = [False] *n__self.diag = [False] * (2 * n) self.anti_diag = [False] * (2 * n) self.result = [] self.recursive(0, n, [])return__self.resultdef__recursive(self, row, n, column):if__row == n: self.result.append(list(map(lambda x: '.' *x__+ 'Q' + '.' * (n - 1 - x), column))) else:for__iin__range(n):if__not self.col[i]and__not self.diag[row + i]and__not self.anti_diag[n -i__+ row]: self.col[i] = self.diag[row + i] = self.anti _diag[n -i__+ row] =True__self.recursive(row + 1, n,column__+ [i]) self.col[i] = self.diag[row + i] = self.anti _diag[n -i__+ row] =False__if__name____== "__main__": print(Solution().solveNQueens(5))Github__(https://github.com/gavinfish/LeetCode-Python) 051 N-Queens 138LeetCode__N-QueensII__N-Queens :n__= 8 : 92 N-QueensAC__052 N-QueensII__139class__Solution(object):def__totalNQueens(self, n): """ :type n:int__:rtype:int__""" self.col = [False] *n__self.diag = [False] * (2 * n) self.anti_diag = [False] * (2 * n) self.result = 0 self.recursive(0, n)return__self.resultdef__recursive(self, row, n):if__row == n: self.result += 1 else:for__iin__range(n):if__not self.col[i]and__not self.diag[row + i]and__not self.anti_diag[n -i__+ row]: self.col[i] = self.diag[row + i] = self.anti _diag[n -i__+ row] =True__self.recursive(row + 1, n) self.col[i] = self.diag[row + i] = self.anti _diag[n -i__+ row] =False__if__name____== "__main__":assert__Solution().totalNQueens(8) == 92Github__(https://github.com/gavinfish/LeetCode-Python) 052 N-QueensII__140LeetCode__MaximumSubarray__:nums__= [-2, 1, -3, 4, -1, 2, 1, -5, 4] : 6( [4, -1, 2, 1] )k__dp[]dp__num[k+1]dp__dpdp__num[k+1] [-2, 1, -3, 4, -1, 2, 1, -5, 4] -3 1 -1 4 -5 4AC__053Maximum__Subarray 141class__Solution(object):def__maxSubArray(self, nums): """ :type nums: List[int] :rtype:int__"""if__not nums:return__0length__= len(nums)current__= nums[0]m__=current__fori__in range(1, length):if__current < 0:current__= 0current__+= nums[i]m__= max(current, m)return__mif____name__ == "__main__":assert__Solution().maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4 ]) == 6Github__(https://github.com/gavinfish/LeetCode-Python) 053Maximum__Subarray 142LeetCode__SpiralMatrix__:matrix__= [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] : [1, 2, 3, 6, 9, 8, 7, 4, 5] 054Spiral__Matrix 143 |3| |3 4 5 6| |2| |3| |4|AC__class Solution(object):def__spiralOrder(self, matrix): """ :type matrix: List[List[int]] :rtype: List[int] """if__not matrix:return__[]left__=top__= 0right__= len(matrix[0]) - 1bottom__= len(matrix) - 1result__= []while__left <right__andtop__< bottom:for__iin__range(left, right): result.append(matrix[top][i])for__iin__range(top, bottom): 054Spiral__Matrix 144 result.append(matrix[i][right])for__iin__range(right, left, -1): result.append(matrix[bottom][i])for__iin__range(bottom, top, -1): result.append(matrix[i][left])left__+= 1right__-= 1top__+= 1bottom__-= 1if__left ==right__andtop__== bottom: result.append(matrix[top][left])elif__left == right:for__iin__range(top,bottom__+ 1): result.append(matrix[i][left])elif__top == bottom:for__iin__range(left,right__+ 1): result.append(matrix[top][i])return__resultif____name__ == "__main__":assert__Solution().spiralOrder([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == [1, 2, 3, 6, 9, 8, 7, 4, 5]assert__Solution().spiralOrder([[2], [3]]) == [2, 3]assert__Solution().spiralOrder([[2, 3]]) == [2, 3]Github__(https://github.com/gavinfish/LeetCode-Python) 054Spiral__Matrix 145LeetCode__JumpGame__:nums__= [2, 3, 1, 1, 4] :True__:nums__= [3, 2, 1, 0, 4] :False__AC 055Jump__Game 146class__Solution(object):def__canJump(self, nums): """ :type nums: List[int] :rtype:bool__"""if__not nums:return__Falselength__= len(nums)index__= 0longest__= nums[0]while__index <= longest:if__longest >=length__- 1:return__Truelongest__= max(longest,index__+ nums[index])index__+= 1return__Falseif____name__ == "__main__":assert__Solution().canJump([2, 3, 1, 1, 4]) ==True__assert Solution().canJump([3, 2, 1, 0, 4]) ==False__Github (https://github.com/gavinfish/LeetCode-Python) 055Jump__Game 147LeetCode__MergeIntervals__:intervals__= [1,3],[2,6],[8,10],[15,18] : [1,6],[8,10],[15,18] (start)AC__056Merge__Intervals 148 #Definition__foran__interval.class__Interval(object):def____init__(self, s=0, e=0): self.start =s__self.end =e__#To__printthe__resultdef____str__(self):return__"[" + str(self.start) + "," + str(self.end) + "]"class__Solution(object):def__merge(self, intervals): """ :type intervals: List[Interval] :rtype: List[Interval] """result__= []if__not intervals:return__result intervals.sort(key=lambda x: x.start) result.append(intervals[0])for__intervalin__intervals[1:]:prev__= result[-1]if__prev.end >= interval.start: prev.end = max(prev.end, interval.end) else: result.append(interval)return__resultif____name__ == "__main__":intervals__= Solution().merge([Interval(1, 3), Interval(2, 6) , Interval(8, 10), Interval(15, 18)])for__intervalin__intervals: print(interval)Github__(https://github.com/gavinfish/LeetCode-Python) 056Merge__Intervals 149 056Merge__Intervals 150LeetCode__InsertInterval__:intervals__= [2,6],[8,10],[15,18]newInterval__= [13,16] : [2,6],[8,10],[13,18]Merge__IntervalsAC__057Insert__Interval 151 #Definition__foran__interval.class__Interval(object):def____init__(self, s=0, e=0): self.start =s__self.end =e__#To__printthe__resultdef____str__(self):return__"[" + str(self.start) + "," + str(self.end) + "]"class__Solution(object):def__insert(self, intervals, newInterval): start,end__= newInterval.start, newInterval.endleft__= list(filter(lambda x: x.end < start, intervals))right__= list(filter(lambda x: x.start > end, intervals))if__len(left) + len(right) != len(intervals):start__= min(start, intervals[len(left)].start)end__= max(end, intervals[-len(right) - 1].end)return__left + [Interval(start, end)] +right__if__name____== "__main__":intervals__= Solution().insert([Interval(2, 6), Interval(8, 10 ), Interval(15, 18)], Interval(13, 16))for__intervalin__intervals: print(interval)Github__(https://github.com/gavinfish/LeetCode-Python) 057Insert__Interval 152LeetCode__Lengthof__LastWord__0 :s__= "Hello world" : 5Python__len(s.strip().split(" ")[-1])AC__058Length__ofLast__Word 153class__Solution(object):def__lengthOfLastWord(self, s): """ :type s:str__:rtype:int__"""length__= len(s)index__=length__- 1while__index >= 0and__s[index] == " ":index__-= 1temp__=index__whileindex__>= 0and__s[index] != " ":index__-= 1return__temp -index__if__name____== "__main__":assert__Solution().lengthOfLastWord(" ") == 0assert__Solution().lengthOfLastWord(" a") == 1assert__Solution().lengthOfLastWord("drfish__") == 6Github__(https://github.com/gavinfish/LeetCode-Python) 058Length__ofLast__Word 154LeetCode__SpiralMatrix__II :n__= 3 : [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]Spiral__MatrixAC__059Spiral__MatrixII__155class__Solution(object):def__generateMatrix(self, n): """ :type n:int__:rtype: List[List[int]] """left__=top__= 0right__=n__- 1bottom__=n__- 1num__= 1result__= [[0for____in__range(n)]for____in__range(n)]while__left <right__andtop__< bottom:for__iin__range(left, right): result[top][i] =num__num += 1for__iin__range(top, bottom): result[i][right] =num__num += 1for__iin__range(right, left, -1): result[bottom][i] =num__num += 1for__iin__range(bottom, top, -1): result[i][left] =num__num += 1left__+= 1right__-= 1top__+= 1bottom__-= 1if__left ==right__andtop__== bottom: result[top][left] =num__returnresult__if__name____== "__main__":assert__Solution().generateMatrix(5) == [[1, 2, 3, 4, 5], [16 , 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]] 059Spiral__MatrixII__156Github__(https://github.com/gavinfish/LeetCode-Python) 059Spiral__MatrixII__157LeetCode__PermutationSequence__[1,2,3...n]k__n 1-9 :n__= 3,k__= 3 : "213"n__n! (n-1)! 1... (n-1)! 2... (n- 1)!+1 2(n-1)!k__(n-1)! 0k__1AC__060Permutation__Sequence 158class__Solution(object):def__getPermutation(self, n, k): """ :type n:int__:type k:int__:rtype:str__"""k__-= 1factorial__= 1for__iin__range(1, n):factorial__*=i__result = []array__= list(range(1,n__+ 1))for__iin__range(n - 1, 0, -1):index__=k__//factorial__result.append(str(array[index]))array__= array[:index] + array[index + 1:]k__%=factorial__factorial //=i__result.append(str(array[0]))return__"".join(result)if____name__ == "__main__":assert__Solution().getPermutation(3, 3) == "213"assert__Solution().getPermutation(9, 324) == "123685974"Github__(https://github.com/gavinfish/LeetCode-Python) 060Permutation__Sequence 159LeetCode__RotateList__kk__:list__= 1->2->3->4->5->NULL,k__= 2 : 4->5->1->2->3->NULLk__kAC__#Definition__for singly-linked list.class__ListNode(object):def____init__(self, x): self.val =x__self.next =None__def myprint(self): print(self.val)if__self.next: self.next.myprint() 061Rotate__List 160class__Solution(object):def__rotateRight(self, head, k): """ :type head:ListNode__:type k:int__:rtype:ListNode__"""if__not head:return__[]curr__=head__length = 1while__curr.next:curr__= curr.nextlength__+= 1 curr.next =head__cur =head__shift =length__-k__%length__whileshift__> 0:curr__= curr.nextshift__-= 1result__= curr.next curr.next =None__returnresult__if__name____== "__main__": l1 = ListNode(1) l2 = ListNode(2) l3 = ListNode(3) l4 = ListNode(4) l5 = ListNode(5) l1.next = l2 l2.next = l3 l3.next = l4 l4.next = l5result__= Solution().rotateRight(l1, 2) result.myprint() 061Rotate__List 161Github__(https://github.com/gavinfish/LeetCode-Python) 061Rotate__List 162LeetCode__UniquePaths__100*100 :m__= 3,n__= 7 : 28 (m-1)+(n-1) (m-1) (n-1)mCn__= n!/m!(n-m)! 062Unique__Paths 163import__mathclass__Solution(object):def__uniquePaths(self, m, n): """ :type m:int__:type n:int__:rtype:int__"""m__-= 1n__-= 1return__math.factorial(m+n) / (math.factorial(n) * math.f actorial(m)) dp[i][j]=dp[i-1][j]+dp[i][j-1] 1AC__class Solution(object):def__uniquePaths(self, m, n): """ :type m:int__:type n:int__:rtype:int__"""dp__= [[1for____in__range(n)]for____in__range(m)]for__iin__range(1, n):for__jin__range(1, m): dp[j][i] = dp[j - 1][i] + dp[j][i - 1]return__dp[m - 1][n - 1]if____name__ == "__main__":assert__Solution().uniquePaths(3, 7) == 28 062Unique__Paths 164Github__(https://github.com/gavinfish/LeetCode-Python) 062Unique__Paths 165LeetCode__UniquePaths__II 0 1 : [ [0,0,0], [0,1,0], [0,0,0] ] : 2Unique__Paths 0AC__063Unique__PathsII__166class__Solution(object):def__uniquePathsWithObstacles(self, obstacleGrid): """ :type obstacleGrid: List[List[int]] :rtype:int__"""if__obstacleGrid[0][0] == 1:return__0m__= len(obstacleGrid)n__= len(obstacleGrid[0])dp__= [[0for____in__range(n)]for____in__range(m)] dp[0][0] = 1for__iin__range(1, m): dp[i][0] = dp[i - 1][0]if__obstacleGrid[i][0] == 0e__lse 0for__jin__range(1, n): dp[0][j] = dp[0][j - 1]if__obstacleGrid[0][j] == 0e__lse 0for__iin__range(1, m):for__jin__range(1, n):if__obstacleGrid[i][j] == 1: dp[i][j] = 0 else: dp[i][j] = dp[i - 1][j] + dp[i][j - 1]return__dp[m - 1][n - 1]if____name__ == "__main__":assert__Solution().uniquePathsWithObstacles([ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) == 2Github__(https://github.com/gavinfish/LeetCode-Python) 063Unique__PathsII__167 063Unique__PathsII__168LeetCode__MinimumPath__Sum : [ [1, 2, 4], [2, 4, 1], [3, 2, 1] ] : 9Unique__Pathsdp__AC 064Minimum__PathSum__169class__Solution(object):def__minPathSum(self, grid): """ :type grid: List[List[int]] :rtype:int__"""m__= len(grid)n__= len(grid[0])dp__= [0for____in__range(n)] dp[0] = grid[0][0]for__jin__range(1, n): dp[j] = dp[j - 1] + grid[0][j]for__iin__range(1, m): dp[0] += grid[i][0]for__jin__range(1, n): dp[j] = min(dp[j], dp[j - 1]) + grid[i][j]return__dp[-1]if____name__ == "__main__":assert__Solution().minPathSum([ [1, 2, 4], [2, 4, 1], [3, 2, 1]]) == 9Github__(https://github.com/gavinfish/LeetCode-Python) 064Minimum__PathSum__170LeetCode__ValidNumber__e " -3.2e-23 " :s__= " -3.2e-23 " :True__"e"e__ee__ACclass__Solution(object):def__isNumber(self, s): """ 065Valid__Number 171 :type s:str__:rtype:bool__"""s__= s.strip()length__= len(s)index__= 0 #Deal__withsymbol__ifindex__<length__and (s[index] == '+'or__s[index] == '-' ):index__+= 1is_normal__=False__is_exp =True__#Deal__withdigits__inthe__frontwhile__index <length__and s[index].isdigit():is_normal__=True__index += 1 #Deal__withdot__antdigits__behindit__ifindex__<length__and s[index] == '.':index__+= 1while__index <length__and s[index].isdigit():is_normal__=True__index += 1 #Deal__with 'e'and__numberbehind__itif__is_normaland__index <length__and (s[index] == 'e'or__s[index] == 'E'):index__+= 1is_exp__=False__ifindex__<length__and (s[index] == '+'or__s[index] = = '-'):index__+= 1while__index <length__and s[index].isdigit():index__+= 1is_exp__=True__#Return__trueonly__dealwith__allthe__charactersand__thepart__infront__ofand__behind 'e'are__allok__returnis_normal__andis_exp__andindex__==length__if__name____== "__main__":assert__Solution().isNumber("3.e-23") ==True__065Valid__Number 172assert__Solution().isNumber(".2e81") ==True__assert Solution().isNumber("2e10") ==True__assert Solution().isNumber(" 0.1") ==True__assert Solution().isNumber("1 b") ==False__assert Solution().isNumber("3-2") ==False__assert Solution().isNumber("abc") ==False__Github (https://github.com/gavinfish/LeetCode-Python) 065Valid__Number 173LeetCode__MinimumPath__Sum : [1, 2, 3, 4, 9] : [1, 2, 3, 5, 0]AC__066Plus__One 174class__Solution(object):def__plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """carry__= 1for__iin__range(len(digits) - 1, -1, -1): digits[i] +=carry__if digits[i] < 10:carry__= 0break__else: digits[i] -= 10if__carry == 1: digits.insert(0, 1)return__digitsif____name__ == "__main__":assert__Solution().plusOne([1, 2, 3, 4, 9]) == [1, 2, 3, 5, 0 ]assert__Solution().plusOne([9]) == [1, 0]Github__(https://github.com/gavinfish/LeetCode-Python) 066Plus__One 175LeetCode__AddBinary__:a__= "111",b__= "1" : "1000"AC__067Add__Binary 176class__Solution(object):def__addBinary(self, a, b): """ :type a:str__:type b:str__:rtype:str__"""result__= []carry__=val__= 0if__len(a) < len(b): a,b__= b,a__lengthA = len(a)lengthB__= len(b)for__iin__range(lengthA):val__=carry__val += int(a[-(i + 1)])if__i < lengthB:val__+= int(b[-(i + 1)]) carry,val__=val__// 2,val__% 2 result.append(str(val))if__carry: result.append(str(carry))return__"".join(result[::-1])if____name__ == "__main__":assert__Solution().addBinary("111", "1") == "1000"Github__(https://github.com/gavinfish/LeetCode-Python) 067Add__Binary 177LeetCode__TextJustification__L ( ) :words__= ["This", "is", "an", "example", "of", "text", "justification."],maxWidth__= 16 : [ "Thisis__an", "exampleof__text", "justification. " ] 068Text__Justification 178AC__class Solution(object):def__fullJustify(self, words, maxWidth): """ :type words: List[str] :type maxWidth:int__:rtype: List[str] """start__=end__= 0 result,curr_words_length__= [], 0for__i,word__in enumerate(words):if__len(word) +curr_words_length__+end__-start__>ma__xWidth:if__end -start__== 1: result.append(words[start] + ' ' * (maxWidth - curr_words_length)) else:total_space__=maxWidth__-curr_words_length__space,extra__= divmod(total_space,end__-sta__rt - 1)for__jin__range(extra): words[start + j] += ' ' result.append((' ' * space).join(words[start :end]))curr_words_length__= 0start__=end__=i__end += 1curr_words_length__+= len(word) result.append(' '.join(words[start:end]) + ' ' * (maxWidth__-curr_words_length__- (end -start__- 1)))return__resultif____name__ == "__main__":assert__Solution().fullJustify(["This", "is", "an", "example" , "of", "text", "justification."], 16) == [ "Thisis__an", "exampleof__text", 068Text__Justification 179 "justification. " ]Github__(https://github.com/gavinfish/LeetCode-Python) 068Text__Justification 180LeetCode__Sqrt(x) :x__= 5 : 2 $$y=x^2+a$$y__$$X0$$ $$X$$y__$$X1$$ $$X1$$ 069 Sqrt(X) 181AC__class Solution(object):def__mySqrt(self, x): """ :type x:int__:rtype:int__"""result__= 1.0while__abs(result *result__- x) > 0.1:result__= (result +x__/ result) / 2return__int(result)if____name__ == "__main__":assert__Solution().mySqrt(5) == 2assert__Solution().mySqrt(0) == 0Github__(https://github.com/gavinfish/LeetCode-Python) 069 Sqrt(X) 182LeetCode__ClimbingStairs__n :n__= 6 : 13 dp[i]=dp[i-1]+dp[i-2]n__1n__2AC__070Climbing__Stairs 183class__Solution(object):def__climbStairs(self, n): """ :type n:int__:rtype:int__"""if__n <= 2:return__ndp__= [0for____in__range(n)] dp[0] = 1 dp[1] = 2for__iin__range(2, n): dp[i] = dp[i - 1] + dp[i - 2]return__dp[n - 1]if____name__ == "__main__":assert__Solution().climbStairs(6) == 13Github__(https://github.com/gavinfish/LeetCode-Python) 070Climbing__Stairs 184LeetCode__SimplifyPath__Unix :path__= "/a/./b/../../c/" : "/c" ".."AC__071Simplify__Path 185class__Solution(object):def__simplifyPath(self, path): """ :type path:str__:rtype:str__"""parts__= path.split("/")result__= ['']for__partin__parts:if__part:if__partnot__in ('.', '..'):if__len(result) == 0: result.append('') result.append(part)elif__part == '..'and__len(result) > 0: result.pop()if__len(result) < 2:return__"/" else:return__"/".join(result)if____name__ == "__main__":assert__Solution().simplifyPath("/a/./b/../../c/") == '/c'assert__Solution().simplifyPath("/home/") == "/home"assert__Solution().simplifyPath("/../../") == "/"Github__(https://github.com/gavinfish/LeetCode-Python) 071Simplify__Path 186LeetCode__EditDistance__: word1 = "heo", word2 = "hello" : 2 dp[i][j] word1[:i] word2[:j] word1[:i-1] word2[:j] word1[i] word1[:i] word2[:j-1] word2[j] word1[:i-1] word2[:j-1] word1[i] word2[j] dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + onemore)AC__072Edit__Distance 187class__Solution(object):def__minDistance(self, word1, word2): """ :type word1:str__:type word2:str__:rtype:int__"""m__= len(word1)n__= len(word2)dp__= [[0for____in__range(m + 1)]for____in__range(n + 1)]for__jin__range(m + 1): dp[0][j] =j__fori__in range(n + 1): dp[i][0] =i__fori__in range(1,n__+ 1):for__jin__range(1,m__+ 1):onemore__= 1if__word1[j - 1] != word2[i - 1]else__0 dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1 , dp[i - 1][j - 1] + onemore)return__dp[n][m]if____name__ == "__main__":assert__Solution().minDistance("", "a") == 1assert__Solution().minDistance("faf", "efef") == 2Github__(https://github.com/gavinfish/LeetCode-Python) 072Edit__Distance 188LeetCode__SetMatrix__Zeroes 0 0 0 :matrix__= [[1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0], [1, 1, 1, 1]] : [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0]] 0 0 0 0 0 0. 073Set__MatrixZeroes__189AC__class Solution(object):def__setZeroes(self, matrix): """ :type matrix: List[List[int]] :rtype:void__Donot__return anything,modify__matrix in-place__instead. """first_row__=False__first_col =False__m = len(matrix)n__= len(matrix[0])for__iin__range(m):if__matrix[i][0] == 0:first_col__=True__forj__in range(n):if__matrix[0][j] == 0:first_row__=True__fori__in range(1, m):for__jin__range(1, n):if__matrix[i][j] == 0: matrix[i][0] = matrix[0][j] = 0for__iin__range(1, m):for__jin__range(1, n):if__matrix[0][j] == 0or__matrix[i][0] == 0: matrix[i][j] = 0if__first_row:for__jin__range(n): matrix[0][j] = 0if__first_col:for__iin__range(m): matrix[i][0] = 0if____name__ == "__main__":matrix__= [[1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0], 073Set__MatrixZeroes__190 [1, 1, 1, 1]] Solution().setZeroes(matrix)assert__matrix == [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 0]]Github__(https://github.com/gavinfish/LeetCode-Python) 073Set__MatrixZeroes__191LeetCode__Searcha__2DMatrix__:matrix__= [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ]target__= 3 :True__i -> [i // n][i % n]i__nAC__074Search__a 2DMatrix__192class__Solution(object):def__searchMatrix(self, matrix, target): """ :type matrix: List[List[int]] :type target:int__:rtype:bool__"""m__= len(matrix)n__= len(matrix[0]) l,h__= 0,m__*n__- 1while__l <= h:mid__=l__+ (h - l) // 2if__matrix[mid // n][mid % n] == target:return__Trueelif__matrix[mid // n][mid % n] < target:l__=mid__+ 1 else:h__=mid__- 1return__Falseif____name__ == "__main__":assert__Solution().searchMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5) ==True__assert Solution().searchMatrix([[1, 2], [3, 4]], 4) ==True__assert Solution().searchMatrix([[1]], 2) ==False__Github (https://github.com/gavinfish/LeetCode-Python) 074Search__a 2DMatrix__193LeetCode__SortColors__0 1 2 :nums__= [1, 2, 1, 2, 0, 2, 1, 0, 2, 0, 0, 2] : [0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 2]AC__075Sort__Colors 194class__Solution(object):def__sortColors(self, nums): """ :type nums: List[int] :rtype:void__Donot__return anything,modify__nums in-place__instead. """left__=mid__= 0right__= len(nums) - 1while__mid <= right:if__nums[mid] == 0: nums[mid], nums[left] = nums[left], nums[mid]left__+= 1mid__+= 1elif__nums[mid] == 1:mid__+= 1 else: nums[mid], nums[right] = nums[right], nums[mid]right__-= 1if____name__ == "__main__":l__= [1, 2, 1, 2, 0, 2, 1, 0, 2, 0, 0, 2] Solution().sortColors(l)assert__l == [0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 2]Github__(https://github.com/gavinfish/LeetCode-Python) 075Sort__Colors 195LeetCode__MinimumWindow__Substring STO(n)T__S "" :s__= "ADOBECODEBANC",t__= "ABC" : "BANC"T__TS__ACfrom__collectionsimport__defaultdictclass__Solution(object):def__minWindow(self, s, t): """ 076Minimum__WindowSubstring__196 :type s:str__:type t:str__:rtype:str__"""MAX_INT__= 2147483647start__=end__= 0char_need__= defaultdict(int) #the__countof__charneed__edby__current window,negative__meanscurrent__windowhas__itbut__not__needsit__count_need = len(t) #count__ofchars__notin__currentwindow__butin__tmin_length__=MAX_INT__min_start = 0for__iin__t: #current__windowneeds__allchar__int__char_need[i] += 1while__end < len(s):if__char_need[s[end]] > 0:count_need__-= 1 #current__windowcontains__s[end] now,so__doesnot__need__itany__more char_need[s[end]] -= 1end__+= 1while__count_need == 0:if__min_length >end__- start:min_length__=end__-start__min_start =start__#current__windowdoes__notcontain__s[start]any__more__char_need[s[start]] += 1 #when__somecount__inchar_need__is positive,it__means__thereis__charin__tbut__notcurrent__windowif__char_need[s[start]] > 0:count_need__+= 1start__+= 1return__""if__min_length ==MAX_INT__else s[min_start:min_start__+ min_length]if____name__ == "__main__": 076Minimum__WindowSubstring__197assert__Solution().minWindow("ADOBECODEBANC", "ABC") == "BANC"Github__(https://github.com/gavinfish/LeetCode-Python) 076Minimum__WindowSubstring__198LeetCode__Combinations 1n__k :n__= 4,k__= 2 : [[1, 4], [2, 4], [3, 4], [1, 3], [2, 3], [1, 2]]nknk__n 1 (n-1) (k-1) 1 (n-1)k__k 1 1n__AC 077Combinations__199class__Solution(object):def__combine(self, n, k): """ :type n:int__:type k:int__:rtype: List[List[int]] """if__k == 1:return__[[i + 1]for__iin__range(n)]result__= []if__n > k:result__= [r + [n]for__rin__self.combine(n - 1,k__- 1 )] + self.combine(n - 1, k) else:result__= [r + [n]for__rin__self.combine(n - 1,k__- 1 )]return__resultif____name__ == "__main__":assert__Solution().combine(4, 2) == [[1, 4], [2, 4], [3, 4], [ 1, 3], [2, 3], [1, 2]]Github__(https://github.com/gavinfish/LeetCode-Python) 077Combinations__200LeetCode__Subsets :nums__= [1,2,3] : [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]Combinations__n n-1 [1] [[],[1]] 078Subsets__201 [1,2] [[],[1],[2],[1,2]]AC__class Solution(object):def__subsets(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """result__= [[]]for__numin__sorted(nums):result__+= [item + [num]for__itemin__result]return__resultif____name__ == "__main__":assert__Solution().subsets([1, 2, 3]) == [[], [1], [2], [1, 2 ], [3], [1, 3], [2, 3], [1, 2, 3]]Github__(https://github.com/gavinfish/LeetCode-Python) 078Subsets__202LeetCode__WordSearch__:board__= [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ]word__= "ABCCED" :True__079Word__Search 203AC__fromcollections__importdefaultdict__class Solution(object):def__exist(self, board, word): """ :type board: List[List[str]] :type word:str__:rtype:bool__"""if__self._hasEnoughCharacters(board, word):m__= len(board)n__= len(board[0])for__iin__range(m):for__jin__range(n):if__self._exist(board, i, j, m, n, word):return__Truereturn__False else:return__Falsedef___exist(self, board, i, j, m, n, word):if__len(word) == 0:return__Trueif__i < 0or__i >=m__orj__< 0or__j >=n__or board[i][j] != word[0]:return__Falsetemp__= board[i][j] board[i][j] = "."next_target__= word[1:]next_result__= self._exist(board,i__- 1, j, m, n,next_ta__rget) \or__self._exist(board,i__+ 1, j, m, n,next___target) \or__self._exist(board, i,j__- 1, m, n,next___target) \or__self._exist(board, i,j__+ 1, m, n,next__079Word__Search 204 _target) board[i][j] =temp__returnnext_result__def _hasEnoughCharacters(self, board, word):character_counts__= defaultdict(int)for__chin__word: character_counts[ch] += 1return__all(sum(map(lambda line: line.count(ch), board)) >=count__for ch,count__in character_counts.items())if____name__ == "__main__":assert__Solution().exist([ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ], "ABCCED") ==True__assert Solution().exist([ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ], "SEE") ==True__assert Solution().exist([ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ], "ABCB") ==False__Github (https://github.com/gavinfish/LeetCode-Python) 079Word__Search 205LeetCode__RemoveDuplicates__fromSorted__ArrayII__RemoveDuplicates__fromSorted__Array 2 2 :nums__= [1,1,1,2,2,3] : 5 ([1,1,2,2,3,3]) [1,1] [1,1,2] [1,1,2,2] [1,1,2,2,3]AC__080Remove__Duplicatesfrom__SortedArray__II 206class__Solution(object):def__removeDuplicates(self, nums): """ :type nums: List[int] :rtype:int__"""count__= 0for__iin__range(len(nums)):if__count < 2or__nums[count - 2] != nums[i]: nums[count] = nums[i]count__+= 1return__countif____name__ == "__main__":l__= [1, 1, 1, 2, 2, 3]r__= Solution().removeDuplicates(l)assert__l == [1, 1, 2, 2, 3, 3]assert__r == 5Github__(https://github.com/gavinfish/LeetCode-Python) 080Remove__Duplicatesfrom__SortedArray__II 207LeetCode__Searchin__RotatedSorted__ArrayII__[0,1,1,1,2,3,4,5] 3 [3,4,5,0,1,1,1,2] :nums__= [4, 5, 5, 6, 7, 0, 1, 2],target__= 4 :True__Searchin__RotatedSorted__ArrayAC__081Search__inRotated__SortedArray__II 208class__Solution(object):def__search(self, nums, target): """ :type nums: List[int] :type target:int__:rtype:int__"""left__= 0right__= len(nums) - 1while__left <= right:mid__=left__+ (right - left) // 2if__nums[mid] == target:return__Trueif__nums[mid] > target:if__nums[left] <=target__or nums[mid] < nums[left ]:right__=mid__- 1 else:left__=mid__+ 1 else:if__nums[left] >target__or nums[mid] >= nums[left ]:left__=mid__+ 1 else:right__=mid__- 1return__Falseif____name__ == "__main__":assert__Solution().search([4, 5, 5, 6, 7, 0, 1, 2], 4) ==True__assert Solution().search([4, 5, 6, 7, 7, 7, 7, 7, 0, 1, 2], 7 ) ==True__Github (https://github.com/gavinfish/LeetCode-Python) 081Search__inRotated__SortedArray__II 209 081Search__inRotated__SortedArray__II 210LeetCode__RemoveDuplicates__fromSorted__ListII__: 1->1->2->3->3 : 2Remove__Duplicatesfrom__SortedList__AC #Definition__for singly-linked list.class__ListNode(object):def____init__(self, x): self.val =x__self.next =None__def my_print(self): 082Remove__Duplicatesfrom__SortedList__II 211 print(self.val)if__self.next: print(self.next.val)class__Solution(object):def__deleteDuplicates(self, head): """ :type head:ListNode__:rtype:ListNode__"""dummy__= ListNode(-1) dummy.next =head__curr =dummy__is_repeat =False__while curr.next:while__curr.next.nextand__curr.next.val == curr.next. next.val: curr.next = curr.next.nextis_repeat__=True__if is_repeat: curr.next = curr.next.nextis_repeat__=False__else:curr__= curr.nextreturn__dummy.nextif____name__ == "__main__": n1 = ListNode(1) n2 = ListNode(1) n3 = ListNode(2) n1.next = n2 n2.next = n3r__= Solution().deleteDuplicates(n1) r.my_print()Github__(https://github.com/gavinfish/LeetCode-Python) 082Remove__Duplicatesfrom__SortedList__II 212 082Remove__Duplicatesfrom__SortedList__II 213LeetCode__RemoveDuplicates__fromSorted__List : 1->1->2->3->3 : 1->2->3AC__083Remove__Duplicatesfrom__SortedList__214 #Definition__for singly-linked list.class__ListNode(object):def____init__(self, x): self.val =x__self.next =None__def my_print(self): print(self.val)if__self.next: print(self.next.val)class__Solution(object):def__deleteDuplicates(self, head): """ :type head:ListNode__:rtype:ListNode__"""curr__=head__while curr:while__curr.nextand__curr.val == curr.next.val: curr.next = curr.next.nextcurr__= curr.nextreturn__headif____name__ == "__main__": n1 = ListNode(1) n2 = ListNode(1) n3 = ListNode(2) n1.next = n2 n2.next = n3r__= Solution().deleteDuplicates(n1) r.my_print()Github__(https://github.com/gavinfish/LeetCode-Python) 083Remove__Duplicatesfrom__SortedList__215 083Remove__Duplicatesfrom__SortedList__216LeetCode__LargestRectangle__inHistogram__1 :heights__= [2,1,5,6,2,3] : 10 2,1,5,6,2,3 084Largest__Rectanglein__Histogram 217 2 4 2 2 0 1 4 1 -1AC__class Solution(object):def__largestRectangleArea(self, heights): """ :type heights: List[int] :rtype:int__""" heights.append(0)stack__= [-1]result__= 0for__iin__range(len(heights)):while__heights[i] < heights[stack[-1]]:h__= heights[stack.pop()]w__=i__- stack[-1] - 1result__= max(result,h__* w) stack.append(i) heights.pop()return__resultif____name__ == "__main__":assert__Solution().largestRectangleArea([2, 1, 5, 6, 2, 3]) = = 10 084Largest__Rectanglein__Histogram 218Github__(https://github.com/gavinfish/LeetCode-Python) 084Largest__Rectanglein__Histogram 219LeetCode__MaximalRectangle__1 0 1 :matrix__= [['1', '1', '0', '1', '0', '1'], ['0', '1', '0', '0', '1', '1'], ['1', '1', '1', '1', '0', '1'], ['1', '1', '1', '1', '0', '1']] : 8Largest__Rectanglein__Histogram 1Largest__Rectanglein__Histogram [1,2,0,0,1,1] 1 0AC__085Maximal__Rectangle 220class__Solution(object):def__maximalRectangle(self, matrix): """ :type matrix: List[List[str]] :rtype:int__"""if__notmatrix__ornot__matrix[0]:return__0n__= len(matrix[0])heights__= [0for____in__range(n + 1)]result__= 0for__rowin__matrix:for__iin__range(n): heights[i] = heights[i] + 1if__row[i] == '1'else__0stack__= [-1]for__iin__range(n + 1):while__heights[i] < heights[stack[-1]]:h__= heights[stack.pop()]w__=i__- stack[-1] - 1result__= max(result,h__* w) stack.append(i)return__resultif____name__ == "__main__":assert__Solution().maximalRectangle([['1', '1', '0', '1', '0' , '1'], ['0', '1', '0', '0', '1' , '1'], ['1', '1', '1', '1', '0' , '1'], ['1', '1', '1', '1', '0' , '1']]) ==8Github__(https://github.com/gavinfish/LeetCode-Python) 085Maximal__Rectangle 221 085Maximal__Rectangle 222LeetCode__PartitionList__:head__= 1->4->3->2->5->2,x__= 3 : 1->2->2->4->3->5None__AC #Definition__for singly-linked list.class__ListNode(object):def____init__(self, x): self.val =x__self.next =None__def to_list(self):return__[self.val] + self.next.to_list()if__self.nextelse__086Partition__List 223 [self.val]class__Solution(object):def__partition(self, head, x): """ :type head:ListNode__:type x:int__:rtype:ListNode__"""dummy__= ListNode(-1) dummy.next =head__small_dummy = ListNode(-1)large_dummy__= ListNode(-1)prev__=dummy__small_prev =small_dummy__large_prev =large_dummy__while prev.next:curr__= prev.nextif__curr.val < x: small_prev.next =curr__small_prev = small_prev.next else: large_prev.next =curr__large_prev = large_prev.nextprev__= prev.next large_prev.next =None__small_prev.next = large_dummy.nextreturn__small_dummy.nextif____name__ == "__main__": n1 = ListNode(1) n2 = ListNode(4) n3 = ListNode(3) n4 = ListNode(2) n5 = ListNode(5) n6 = ListNode(2) n1.next = n2 086Partition__List 224 n2.next = n3 n3.next = n4 n4.next = n5 n5.next = n6r__= Solution().partition(n1, 3)assert__r.to_list() == [1, 2, 2, 4, 3, 5]Github__(https://github.com/gavinfish/LeetCode-Python) 086Partition__List 225LeetCode__ScrambleString__: s1 = "rgtae", s2 = "great" :True__("rgtae"->"grtae"->"greta"->"great")STS__TS__STTS__AC 087Scramble__String 226from__collectionsimport__defaultdictclass__Solution(object):def__isScramble(self, s1, s2): """ :type s1:str__:type s2:str__:rtype:bool__"""if__s1 == s2:return__True count1 = defaultdict(int) count2 = defaultdict(int)for__e1, e2in__zip(s1, s2): count1[e1] += 1 count2[e2] += 1if__count1 != count2:return__Falsefor__iin__range(1, len(s1)):if__self.isScramble(s1[:i], s2[:i])and__self.isScramb le(s1[i:], s2[i:]) \or__self.isScramble(s1[:i], s2[-i:])and__self .isScramble(s1[i:], s2[:len(s2) - i]):return__Truereturn__FalseGithub__(https://github.com/gavinfish/LeetCode-Python) 087Scramble__String 227LeetCode__MergeSorted__Arraym__n : nums1 = [1, 1, 2, 2, 4, 0, 0, 0, 0],m__= 5, nums2 = [0, 0, 2, 3],n__= 4 : nums1 [0, 0, 1, 1, 2, 2, 2, 3, 4]AC__088Merge__SortedArray__228class__Solution(object):def__merge(self, nums1, m, nums2, n): """ :type nums1: List[int] :type m:int__:type nums2: List[int] :type n:int__:rtype:void__Donot__return anything,modify__nums1 in-place__instead. """index__=m__+n__- 1m__-= 1n__-= 1while__m >= 0and__n >= 0:if__nums1[m] > nums2[n]: nums1[index] = nums1[m]m__-= 1 else: nums1[index] = nums2[n]n__-= 1index__-= 1if__m < 0: nums1[:n + 1] = nums2[:n + 1]if____name__ == "__main__": num1 = [1, 1, 2, 2, 4, 0, 0, 0, 0] num2 = [0, 0, 2, 3] Solution().merge(num1, 5, num2, 4)assert__num1 == [0, 0, 1, 1, 2, 2, 2, 3, 4]Github__(https://github.com/gavinfish/LeetCode-Python) 088Merge__SortedArray__229LeetCode__GrayCode__:n__= 2 : [0,1,3,2] 00 - 0 01 - 1 11 - 3 10 - 2AC__089Gray__Code 230class__Solution(object):class__Solution(object):def__grayCode(self, n): """ :type n:int__:rtype: List[int] """result__= [(i >> 1) ^i__fori__in range(pow(2, n))]return__resultif____name__ == "__main__":assert__Solution().grayCode(2) == [0, 1, 3, 2]Github__(https://github.com/gavinfish/LeetCode-Python) 089Gray__Code 231LeetCode__SubsetsII__:nums__= [1,2,2] : [ [2], [1], [1,2,2], [2,2], [1,2], [] ]Subsets__[1,2,2] 1 [[], [1]] 2 [[], [1], [2], [1,2]] 2 2 [[], [1]] 090Subsets__II 232AC__class Solution(object):def__subsetsWithDup(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """result__= [[]] nums.sort()temp_size__= 0for__iin__range(len(nums)):start__=temp_size__ifi__>= 1and__nums[i] == nums[i - 1 ]else__0temp_size__= len(result)for__jin__range(start, temp_size): result.append(result[j] + [nums[i]])return__resultif____name__ == "__main__":assert__Solution().subsetsWithDup([1, 2, 2]) == [[], [1], [2] , [1, 2], [2, 2], [1, 2, 2]]Github__(https://github.com/gavinfish/LeetCode-Python) 090Subsets__II 233LeetCode__DecodeWays__1-A, 2-B, ...26-Z "70" 0 :s__= "12" : 2 "AB"(1 2) "L"(12) "y231" "xy231"x__0 "xy" 1-26x__"xy" 1-26x__"231" "xy"x__0 0AC__091Decode__Ways 234class__Solution(object):def__numDecodings(self, s): """ :type s:str__:rtype:int__"""length__= len(s)if__length == 0:return__0dp__= [0for____in__range(length + 1)] dp[length] = 1 dp[length - 1] = 1if__s[length - 1] != '0'else__0for__iin__range(length - 2, -1, -1):if__s[i] != '0': dp[i] = dp[i + 1] + dp[i + 2]if__int(s[i:i + 2]) <= 26else__dp[i + 1]return__dp[0]if____name__ == "__main__":assert__Solution().numDecodings("110") == 1assert__Solution().numDecodings("40") == 0Github__(https://github.com/gavinfish/LeetCode-Python) 091Decode__Ways 235LeetCode__ReverseLinked__ListII__mn__mn__1m__n : 1->2->3->4->5->NULL,m__= 2,n__= 4 : 1->4->3->2->5->NULLReverse__LinkedList__AC #Definition__for singly-linked list.class__ListNode(object):def____init__(self, x): self.val =x__self.next =None__def to_list(self):return__[self.val] + self.next.to_list()if__self.nextelse__092Reverse__LinkedList__II 236 [self.val]class__Solution(object):def__reverseBetween(self, head, m, n): """ :type head:ListNode__:type m:int__:type n:int__:rtype:ListNode__"""dummy__= ListNode(-1) dummy.next =head__node =dummy__for____in range(m - 1):node__= node.nextprev__= node.nextcurr__= prev.nextfor____in__range(n - m):next__= curr.next curr.next =prev__prev =curr__curr =next__node.next.next =curr__node.next =prev__return dummy.nextif____name__ == "__main__": n1 = ListNode(1) n2 = ListNode(2) n3 = ListNode(3) n4 = ListNode(4) n5 = ListNode(5) n1.next = n2 n2.next = n3 n3.next = n4 n4.next = n5r__= Solution().reverseBetween(n1, 2, 4)assert__r.to_list() == [1, 4, 3, 2, 5] 092Reverse__LinkedList__II 237Github__(https://github.com/gavinfish/LeetCode-Python) 092Reverse__LinkedList__II 238LeetCode__RestoreIP__AddressesIP__IP 0-255 :s__= "25525511135" : ["255.255.11.135", "255.255.111.35"] 1 3IP__0 01.0.0.0IP__255IP__IP 4AC__093Restore__IPAddresses__239class__Solution(object):def__restoreIpAddresses(self, s): """ :type s:str__:rtype: List[str] """result__= [] self._restoreIpAddresses(0, s, [], result)return__resultdef___restoreIpAddresses(self, length, s, ips, result):if__not s:if__length == 4: result.append('.'.join(ips))return__eliflength__== 4:return__self._restoreIpAddresses(length + 1, s[1:],ips__+ [s[:1] ], result)if__s[0] != '0':if__len(s) >= 2: self._restoreIpAddresses(length + 1, s[2:],ips__+ [s[:2]], result)if__len(s) >= 3and__int(s[:3]) <= 255: self._restoreIpAddresses(length + 1, s[3:],ips__+ [s[:3]], result)if____name__ == "__main__":assert__Solution().restoreIpAddresses("25525511135") == ['255 .255.11.135', '255.255.111.35']Github__(https://github.com/gavinfish/LeetCode-Python) 093Restore__IPAddresses__240LeetCode__BinaryTree__InorderTraversal__: {1,#,2,3} 1 \ 2 / 3 : [1,3,2]AC__094Binary__TreeInorder__Traversal 241 #Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__inorderTraversal(self, root): """ :type root:TreeNode__:rtype: List[int] """result__= []stack__= []p__=root__whilep__or stack: #Save__thenodes__whichhave__leftchild__while p: stack.append(p)p__= p.leftif__stack:p__= stack.pop() #Visit__themiddle__node result.append(p.val) #Visit__theright__subtreep__= p.rightreturn__resultif____name__ == "__main__": n1 = TreeNode(1) n2 = TreeNode(2) n3 = TreeNode(3) n1.right = n2 n2.left = n3assert__Solution().inorderTraversal(n1) == [1, 3, 2] 094Binary__TreeInorder__Traversal 242Github__(https://github.com/gavinfish/LeetCode-Python) 094Binary__TreeInorder__Traversal 243LeetCode__UniqueBinary__SearchTrees__II 1n__nn__:n__= 3 : 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3Unique__BinarySearch__Treesmap__AC 095Unique__BinarySearch__TreesII__244 #Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__generateTrees(self, n): """ :type n:int__:rtype: List[TreeNode] """if__n == 0:return__[] self.cache = {}return__self._generateTrees(1, n)def___generateTrees(self, start, end):if__(start, end)not__in self.cache:roots__= []for__rootin__range(start,end__+ 1):for__leftin__self._generateTrees(start,root__- 1) :for__rightin__self._generateTrees(root + 1,e__nd):node__= TreeNode(root) node.left =left__node.right =right__roots.append(node) self.cache[(start, end)] =roots__return self.cache[(start, end)]or__[None]if____name__ == "__main__":None__095Unique__BinarySearch__TreesII__245Github__(https://github.com/gavinfish/LeetCode-Python) 095Unique__BinarySearch__TreesII__246LeetCode__UniqueBinary__SearchTrees__1n__nn__:n__= 3 : 5 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3n__1n__k k-1 n-kk__h(n) = h(0)*h(n-1) + h(1)*h(n-2) + ... + h(n- 1)h(0) ( n>=2) h(0)=h(1)=1 0 1 1n__h(x)AC__096Unique__BinarySearch__Trees 247class__Solution(object):def__numTrees(self, n): """ :type n:int__:rtype:int__"""dp__= [1for____in__range(n + 1)]for__iin__range(2,n__+ 1):s__= 0for__jin__range(i):s__+= dp[j] * dp[i - 1 - j] dp[i] =s__return dp[-1]if____name__ == "__main__":assert__Solution().numTrees(5) == 42Github__(https://github.com/gavinfish/LeetCode-Python) 096Unique__BinarySearch__Trees 248LeetCode__InterleavingString__s1 s2 s3 s3 s1 s2 s1 s2 : s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac" :True__dp[i][j] s1[:i+1] s2[:j+1] s3[:i+j+1] dp[0][0]True__dp[i][j]True__1. s1[i] == s3[i+j] dp[i-1][j]True__2. s2[j] == s3[i+j] dp[i][j-1]True__dp[i + 1][j + 1] = (dp[j + 1][i]and__s1[i] == s3[i +j__+ 1])or__(dp[j][i + 1]and__s2[j] == s3[i +j__+ 1])dp__AC 097Interleaving__String 249class__Solution(object):def__isInterleave(self, s1, s2, s3): """ :type s1:str__:type s2:str__:type s3:str__:rtype:bool__"""m__= len(s1)n__= len(s2)l__= len(s3)if__m +n__!= l:return__Falsedp__= [Truefor____in__range(m + 1)]for__iin__range(m): dp[i + 1] = dp[i]and__s1[i] == s3[i]for__jin__range(n): dp[0] = dp[0]and__s2[j] == s3[j]for__iin__range(m): dp[i + 1] = (dp[i]and__s1[i] == s3[i +j__+ 1])or__(dp[i + 1]and__s2[j] == s3[i +j__+ 1])return__dp[m]if____name__ == "__main__":assert__Solution().isInterleave("aabcc", "dbbca", "aadbbcbcac" ) ==True__assert Solution().isInterleave("aabcc", "dbbca", "aadbbbaccc" ) ==False__Github (https://github.com/gavinfish/LeetCode-Python) 097Interleaving__String 250LeetCode__ValidateBinary__SearchTree__: 2 / \ 1 3 :True__BinaryTree__InorderTraversal__AC 098Validate__BinarySearch__Tree 251 #Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__isValidBST(self, root): """ :type root:TreeNode__:rtype:bool__"""stack__= []curr__=root__prev =None__whilecurr__or stack:while__curr: stack.append(curr)curr__= curr.leftif__stack:curr__= stack.pop()if__prevand__curr.val <= prev.val:return__Falseprev__=curr__curr = curr.rightreturn__Trueif____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 098Validate__BinarySearch__Tree 252 098Validate__BinarySearch__Tree 253LeetCode__RecoverBinary__SearchTree__: 3 / \ 1 2 : 2 / \ 1 3 099Recover__BinarySearch__Tree 254AC__#Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def____init__(self): self.node1 =None__self.node2 =None__self.pre =None__def recoverTree(self, root): """ :type root:TreeNode__:rtype:void__Donot__return anything,modify__root in-place__instead. """ self.__scan(root) self.node1.val, self.node2.val = self.node2.val, self.no de1.valdef____scan(self, root):if__rootis__None:return__self.__scan(root.left)if__self.preis__not None:if__root.val < self.pre.val:if__self.node1is__None: self.node1 = self.pre self.node2 =root__else: self.node2 =root__self.pre =root__self.__scan(root.right) 099Recover__BinarySearch__Tree 255if____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 099Recover__BinarySearch__Tree 256LeetCode__SameTree__: 2 2p__= / \q__= / \ 1 3 1 3 :True__AC 100Same__Tree 257 #Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__isSameTree(self, p, q): """ :type p:TreeNode__:type q:TreeNode__:rtype:bool__"""if__notq__andnot__p:return__Trueelif__notp__ornot__q:return__Falseelif__p.val != q.val:return__False else:return__self.isSameTree(p.left, q.left)and__self.isSa meTree(p.right, q.right)if____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 100Same__Tree 258LeetCode__SymmetricTree__: 1 / \ 2 2 / \ / \ 3 4 4 3 :True__: 1 / \ 2 2 \ \ 3 3 :False__101Symmetric__Tree 259A__BABABAB__AC #Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object): #Solve__itrecursively__def isSymmetric(self, root): """ :type root:TreeNode__:rtype:bool__"""if__not root:return__Truereturn__self._isSymmetric(root.left, root.right)def___isSymmetric(self, left, right):if__notleft__andnot__right:return__Trueif__notleft__ornot__right:return__Falseif__left.val != right.val:return__Falsereturn__self._isSymmetric(left.left, right.right)and__sel f._isSymmetric(left.right, right.left) #Solve__ititeratively__101Symmetric__Tree 260def__isSymmetric_iterate(self, root): """ :type root:TreeNode__:rtype:bool__"""if__not root:return__True stack1, stack2 = [], [] stack1.append(root.left) stack2.append(root.right)while__stack1and__stack2: size1 = len(stack1) size2 = len(stack2)if__size1 != size2:return__Falsefor____in__range(size1): curr1, curr2 = stack1.pop(), stack2.pop()if__not curr1and__not curr2:continue__ifnot__curr1or__not curr2:return__Falseif__curr1.val != curr2.val:return__False stack1.append(curr1.left) stack1.append(curr1.right) stack2.append(curr2.right) stack2.append(curr2.left)return__not stack1and__not stack2if____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 101Symmetric__Tree 261LeetCode__BinaryTree__LevelOrder__Traversal : 3 / \ 9 20 / \ 15 7 : [ [3], [9,20], [15,7] ] 102Binary__TreeLevel__OrderTraversal__262AC__#Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__levelOrder(self, root): """ :type root:TreeNode__:rtype: List[List[int]] """result__= []if__not root:return__resultcurr_level__= [root]while__curr_level:level_result__= []next_level__= []for__tempin__curr_level: level_result.append(temp.val)if__temp.left: next_level.append(temp.left)if__temp.right: next_level.append(temp.right) result.append(level_result)curr_level__=next_level__returnresult__if__name____== "__main__":None__102Binary__TreeLevel__OrderTraversal__263Github__(https://github.com/gavinfish/LeetCode-Python) 102Binary__TreeLevel__OrderTraversal__264LeetCode__BinaryTree__ZigzagLevel__OrderTraversal__: 3 / \ 9 20 / \ 15 7 : [ [3], [20,9], [15,7] ]Binary__TreeLevel__OrderTraversal__103Binary__TreeZigzag__LevelOrder__Traversal 265AC__class Solution(object):def__zigzagLevelOrder(self, root): """ :type root:TreeNode__:rtype: List[List[int]] """result__= []if__not root:return__resultcurr_level__= [root]need_reverse__=False__while curr_level:level_result__= []next_level__= []for__tempin__curr_level: level_result.append(temp.val)if__temp.left: next_level.append(temp.left)if__temp.right: next_level.append(temp.right)if__need_reverse: level_result.reverse()need_reverse__=False__else:need_reverse__=True__result.append(level_result)curr_level__=next_level__returnresult__if__name____== "__main__":None__103Binary__TreeZigzag__LevelOrder__Traversal 266Github__(https://github.com/gavinfish/LeetCode-Python) 103Binary__TreeZigzag__LevelOrder__Traversal 267LeetCode__MaximumDepth__ofBinary__Tree : : 3 / \ 9 20 / \ 15 7 / 14 : 4AC__104Maximum__Depthof__BinaryTree__268 #Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__maxDepth(self, root): """ :type root:TreeNode__:rtype:int__"""if__not root:return__0return__max(self.maxDepth(root.left), self.maxDepth(root. right)) + 1if____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 104Maximum__Depthof__BinaryTree__269LeetCode__ConstructBinary__Treefrom__Preorderand__InorderTraversal__: :preorder__= [3,9,20,15,14,7],inorder__= [9,3,14,15,20,7] : 3 / \ 9 20 / \ 15 7 / 14 1. , 2. 3. 105Construct__BinaryTree__fromPreorder__andInorder__Traversal 270AC__#Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__buildTree(self, preorder, inorder): """ :type preorder: List[int] :type inorder: List[int] :rtype:TreeNode__""" self.preorder =preorder__self.inorder =inorder__return self._buildTree(0, len(preorder), 0, len(inorder) )def___buildTree(self, pre_start, pre_end, in_start, in_end):if__pre_start >= pre_end:return__Noneroot__= TreeNode(self.preorder[pre_start])offset__= self.inorder[in_start:in_end + 1].index(root.va l) root.left = self._buildTree(pre_start + 1,pre_start__+o__ffset + 1, in_start,in_start__+ offset) root.right = self._buildTree(pre_start +offset__+ 1,pre___end,in_start__+offset__+ 1, in_end)return__rootif____name__ == "__main__":None__105Construct__BinaryTree__fromPreorder__andInorder__Traversal 271Github__(https://github.com/gavinfish/LeetCode-Python) 105Construct__BinaryTree__fromPreorder__andInorder__Traversal 272LeetCode__ConstructBinary__Treefrom__Inorderand__PostorderTraversal__: :inorder__= [9,3,14,15,20,7],postorder__= [9,14,15,7,20,3] : 3 / \ 9 20 / \ 15 7 / 14 1. , 2. 3.AC__106Construct__BinaryTree__fromInorder__andPostorder__Traversal 273 #Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__buildTree(self, inorder, postorder): """ :type inorder: List[int] :type postorder: List[int] :rtype:TreeNode__""" self.postorder =postorder__self.inorder =inorder__return self._buildTree(0, len(inorder))def___buildTree(self, start, end):if__start < end:root__= TreeNode(self.postorder.pop())index__= self.inorder.index(root.val) root.right = self._buildTree(index + 1, end) root.left = self._buildTree(start, index)return__rootif____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 106Construct__BinaryTree__fromInorder__andPostorder__Traversal 274LeetCode__BinaryTree__LevelOrder__TraversalII__: : 3 / \ 9 20 / \ 15 7 : [ [15,7], [9,20], [3] ]Binary__TreeLevel__OrderTraversal__107Binary__TreeLevel__OrderTraversal__II 275AC__#Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__levelOrderBottom(self, root): """ :type root:TreeNode__:rtype: List[List[int]] """result__= []if__not root:return__resultcurr_level__= [root]while__curr_level:level_result__= []next_level__= []for__tempin__curr_level: level_result.append(temp.val)if__temp.left: next_level.append(temp.left)if__temp.right: next_level.append(temp.right) result.append(level_result)curr_level__=next_level__result.reverse()return__resultif____name__ == "__main__":None__107Binary__TreeLevel__OrderTraversal__II 276Github__(https://github.com/gavinfish/LeetCode-Python) 107Binary__TreeLevel__OrderTraversal__II 277LeetCode__ConvertSorted__Arrayto__BinarySearch__Tree : :nums__= [1,2,3] : 2 / \ 1 3 1AC__108Convert__SortedArray__toBinary__SearchTree__278 #Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__sortedArrayToBST(self, nums): """ :type nums: List[int] :rtype:TreeNode__"""return__self._sortedArrayToBST(nums, 0, len(nums))def___sortedArrayToBST(self, nums, left, right):if__left == right:return__Nonemid__= (left + right) >> 1root__= TreeNode(nums[mid]) root.left = self._sortedArrayToBST(nums, left, mid) root.right = self._sortedArrayToBST(nums,mid__+ 1,right__)return__rootif____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 108Convert__SortedArray__toBinary__SearchTree__279LeetCode__ConvertSorted__Listto__BinarySearch__Tree : :nums__= 1->2->3 : 2 / \ 1 3Convert__SortedArray__toBinary__SearchTree__AC #Definition__for singly-linked list.class__ListNode(object):def____init__(self, x): self.val =x__109Convert__SortedList__toBinary__SearchTree__280 self.next =None__#Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__sortedListToBST(self, head): """ :type head:ListNode__:rtype:TreeNode__""" node,length__= head, 0while__node:node__= node.nextlength__+= 1 self.curr =head__return self._sortedListToBST(0,length__- 1)def___sortedListToBST(self, left, right):if__left > right:return__Nonemid__= (left + right) // 2left__= self._sortedListToBST(left,mid__- 1)root__= TreeNode(self.curr.val) root.left =left__self.curr = self.curr.next root.right = self._sortedListToBST(mid + 1, right)return__rootif____name__ == "__main__":None__109Convert__SortedList__toBinary__SearchTree__281Github__(https://github.com/gavinfish/LeetCode-Python) 109Convert__SortedList__toBinary__SearchTree__282LeetCode__BalancedBinary__Tree 1 : : 3 / \ 9 20 / \ 15 7 / 14 :False__-1 | | 1 -1AC__110Balanced__BinaryTree__283 #Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__isBalanced(self, root): """ :type root:TreeNode__:rtype:bool__"""return__self._isBalanced(root) >= 0def___isBalanced(self, root):if__not root:return__0 left,right__= self._isBalanced(root.left), self._isBalan ced(root.right)if__left >= 0and__right >= 0and__abs(left - right) <= 1:return__1 + max(left, right) else:return__-1if____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 110Balanced__BinaryTree__284LeetCode__MinimumDepth__ofBinary__Tree : : 3 / \ 9 20 / \ 15 7 / 14 : 2Binary__TreeLevel__OrderTraversal__AC 111Minimum__Depthof__BinaryTree__285 #Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__minDepth(self, root): """ :type root:TreeNode__:rtype:int__"""if__rootis__None:return__0 depth,curr_level__= 0, [root]while__curr_level:depth__+= 1next_level__= []for__nin__curr_level: left,right__= n.left, n.rightif__leftis__Noneand__rightis__None:return__depthif__left: next_level.append(left)if__right: next_level.append(right)curr_level__=next_level__returndepth__if__name____== "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 111Minimum__Depthof__BinaryTree__286 111Minimum__Depthof__BinaryTree__287LeetCode__PathSum__: :sum__= 12 3 / \ 9 20 / \ 15 7 / 14 :True__(3->9) 0AC__112Path__Sum 288 #Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__hasPathSum(self, root, sum): """ :type root:TreeNode__:type sum:int__:rtype:bool__"""if__not root:return__Falsesum__-= root.valif__sum == 0and__root.leftis__Noneand__root.rightis__None :return__Truereturn__self.hasPathSum(root.left, sum)or__self.hasPathSu m(root.right, sum)if____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 112Path__Sum 289LeetCode__PathSum__II : : 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 : [ [5,4,11,2], [5,8,4,5] ] 113Path__SumII__290Path__Sumdfs__AC 113Path__SumII__291 #Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__pathSum(self, root, sum): """ :type root:TreeNode__:type sum:int__:rtype: List[List[int]] """result__= [] self._pathSum(root, sum, [], result)return__resultdef___pathSum(self, root, sum, curr, result):if__not root:return__sum -= root.valif__sum == 0and__root.leftis__Noneand__root.rightis__None : result.append(curr + [root.val])if__root.left: self._pathSum(root.left, sum,curr__+ [root.val],res__ult)if__root.right: self._pathSum(root.right, sum,curr__+ [root.val],re__sult)if____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 113Path__SumII__292 113Path__SumII__293LeetCode__FlattenBinary__Treeto__LinkedList__: : 1 / \ 2 5 / \ \ 3 4 6 : 1 \ 2 \ 3 \ 4 \ 5 \ 6 114Flatten__BinaryTree__toLinked__List 294AC__#Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__flatten(self, root): """ :type root:TreeNode__:rtype:void__Donot__return anything,modify__root in-place__instead. """stack__= []while__root:if__root.left:if__root.right: stack.append(root.right) root.right, root.left = root.left,None__ifnot__root.rightand__stack: root.right = stack.pop()root__= root.rightif____name__ == "__main__":None__114Flatten__BinaryTree__toLinked__List 295Github__(https://github.com/gavinfish/LeetCode-Python) 114Flatten__BinaryTree__toLinked__List 296LeetCode__DistinctSubsequences__STTSSS__T : :s__= "rabbbit",t__= "rabbit" : 3 dp[i][j] S[:i] T[:j] S[i-1] T[j-1] S[:i-1] T[:j] dp[i][j] = dp[i-1][j] S[i-1] T[j-1] S[i-1] T[j-1] S[:i-1] dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]AC__115Distinct__Subsequences 297class__Solution(object):def__numDistinct(self, s, t): """ :type s:str__:type t:str__:rtype:int__"""m__= len(s)n__= len(t)dp__= [0for____in__range(n + 1)] dp[0] = 1for__iin__range(m):for__jin__range(n - 1, -1, -1):if__t[j] == s[i]: dp[j + 1] += dp[j]return__dp[-1]if____name__ == "__main__":assert__Solution().numDistinct("rabbbit", "rabbit") == 3Github__(https://github.com/gavinfish/LeetCode-Python) 115Distinct__Subsequences 298LeetCode__PopulatingNext__RightPointers__inEach__Nodenext__None : 1 / \ 2 3 / \ / \ 4 5 6 7 : 1 ->NULL__/ \ 2 -> 3 ->NULL__/ \ / \ 4->5->6->7 ->NULL__116Populating__NextRight__Pointersin__EachNode__299AC__#Definition__forbinary__treewith__next pointer.class__TreeLinkNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__self.next =None__class Solution(object):def__connect(self, root): """ :type root:TreeLinkNode__:rtype:nothing__"""if__not root:return__current_level = [root]while__current_level:next_level__= []for__nodein__current_level:if__node.left: next_level.append(node.left)if__node.right: next_level.append(node.right)for__iin__range(len(next_level) - 1): next_level[i].next = next_level[i + 1]current_level__=next_level__if__name____== "__main__":None__116Populating__NextRight__Pointersin__EachNode__300Github__(https://github.com/gavinfish/LeetCode-Python) 116Populating__NextRight__Pointersin__EachNode__301LeetCode__PopulatingNext__RightPointers__inEach__NodeII__nextNone__PopulatingNext__RightPointers__inEach__Node : 1 / \ 2 3 / \ \ 4 5 7 : 1 ->NULL__/ \ 2 -> 3 ->NULL__/ \ \ 4-> 5 -> 7 ->NULL__117Populating__NextRight__Pointersin__EachNode__II 302Populating__NextRight__Pointersin__EachNode__nextroot__nodeAC__117Populating__NextRight__Pointersin__EachNode__II 303 #Definition__forbinary__treewith__next pointer.class__TreeLinkNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__self.next =None__class Solution(object):def__connect(self, root): """ :type root:TreeLinkNode__:rtype:nothing__"""dummy__= TreeLinkNode(-1)node__=dummy__while root:while__root: node.next = root.leftnode__= node.nextor__node node.next = root.rightnode__= node.nextor__noderoot__= root.next root,node__= dummy.next,dummy__if__name____== "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 117Populating__NextRight__Pointersin__EachNode__II 304LeetCode__Pascal'sTriangle__n : :numRows__= 5 : [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 1 [1,3,3,1] [1+3,3+3,3+1] [1,3,3] [3,3,1]AC__118 Pascal'sTriangle__305class__Solution(object):def__generate(self, numRows): """ :type numRows:int__:rtype: List[List[int]] """if__not numRows:return__[]result__= [[1]]while__numRows > 1: result.append([1] + [a +b__for a,b__in zip(result[-1 ][:-1], result[-1][1:])] + [1])numRows__-= 1return__resultif____name__ == "__main__":assert__Solution().generate(4) == [[1], [1, 1], [1, 2, 1], [1 , 3, 3, 1]]Github__(https://github.com/gavinfish/LeetCode-Python) 118 Pascal'sTriangle__306LeetCode__Pascal'sTriangle__II O(k)k__0 0 [1] : :k__= 3 : [1,3,3,1] [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] Pascal'sTriangle__k (k+1)AC__119 Pascal'sTriangle__II 307class__Solution(object):def__getRow(self, rowIndex): """ :type rowIndex:int__:rtype: List[int] """result__= [1] * (rowIndex + 1)for__iin__range(2,rowIndex__+ 1):for__jin__range(1, i): result[i - j] += result[i -j__- 1]return__resultif____name__ == "__main__":assert__Solution().getRow(3) == [1, 3, 3, 1]Github__(https://github.com/gavinfish/LeetCode-Python) 119 Pascal'sTriangle__II 308LeetCode__Triangle O(n)n__: : [ [2], [3,4], [6,5,7], [4,1,8,3] ] : 11 (2 + 3 + 5 + 1 = 11) [ [2], [3,4], [6,5,7], [4,1,8,3] ] 120Triangle__309 dp[i]i__dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])AC__class Solution(object):def__minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype:int__"""n__= len(triangle)dp__= triangle[-1]for__iin__range(n - 2, -1, -1):for__jin__range(i + 1): dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])return__dp[0]if____name__ == "__main__":assert__Solution().minimumTotal([ [2], [3, 4], [6, 5, 7], [4, 1, 8, 3] ]) == 11Github__(https://github.com/gavinfish/LeetCode-Python) 120Triangle__310LeetCode__BestTime__toBuy__andSell__Stock : :prices__= [2, 4, 6, 1, 3, 8, 3] : 7( 1 8 )AC__121Best__Timeto__Buyand__SellStock__311class__Solution(object):def__maxProfit(self, prices): """ :type prices: List[int] :rtype:int__"""if__len(prices) < 2:return__0min_price__= prices[0]max_profit__= 0for__pricein__prices:if__price < min_price:min_price__=price__ifprice__-min_price__> max_profit:max_profit__=price__-min_price__returnmax_profit__if__name____== "__main__":assert__Solution().maxProfit([2, 4, 6, 1, 3, 8, 3]) == 7Github__(https://github.com/gavinfish/LeetCode-Python) 121Best__Timeto__Buyand__SellStock__312LeetCode__BestTime__toBuy__andSell__StockII__: :prices__= [2, 4, 6, 1, 3, 8, 3] : 11([2,6] [1,8] )AC__122Best__Timeto__Buyand__SellStock__II 313class__Solution(object):def__maxProfit(self, prices): """ :type prices: List[int] :rtype:int__"""if__not prices:return__0low__=high__= prices[0]profit__= 0for__iin__range(1, len(prices)):if__prices[i] >= prices[i - 1]:high__= prices[i] else:profit__+=high__-low__low =high__= prices[i]profit__+=high__-low__returnprofit__if__name____== "__main__":assert__Solution().maxProfit([2, 4, 6, 1, 3, 8, 3]) == 11Github__(https://github.com/gavinfish/LeetCode-Python) 122Best__Timeto__Buyand__SellStock__II 314LeetCode__BestTime__toBuy__andSell__StockIII__: :prices__= [2, 4, 6, 1, 3, 8, 3] : 11([2,6] [1,8] )Best__Timeto__Buyand__SellStock__BestTime__toBuy__andSell__StockAC__123Best__Timeto__Buyand__SellStock__III 315class__Solution(object):def__maxProfit(self, prices): """ :type prices: List[int] :rtype:int__"""total_max_profit__= 0n__= len(prices)first_profits__= [0] *n__min_price = float('inf')for__iin__range(n):min_price__= min(min_price, prices[i])total_max_profit__= max(total_max_profit, prices[i] - min_price) first_profits[i] =total_max_profit__max_profit = 0max_price__= float('-inf')for__iin__range(n - 1, 0, -1):max_price__= max(max_price, prices[i])max_profit__= max(max_profit,max_price__- prices[i])total_max_profit__= max(total_max_profit,max_profit__+ first_profits[i - 1])return__total_max_profitif____name__ == "__main__":assert__Solution().maxProfit([2, 4, 6, 1, 3, 8, 3]) == 11assert__Solution().maxProfit([1, 2]) == 1Github__(https://github.com/gavinfish/LeetCode-Python) 123Best__Timeto__Buyand__SellStock__III 316LeetCode__BinaryTree__MaximumPath__Sum : : 1 / \ 2 3 : 6AC__124Binary__TreeMaximum__PathSum__317 #Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__maxPathSum(self, root): """ :type root:TreeNode__:rtype:int__""" self.maxSum = float('-inf') self._maxPathSum(root)return__self.maxSumdef___maxPathSum(self, root):if__rootis__None:return__0left__= self._maxPathSum(root.left)right__= self._maxPathSum(root.right)left__=left__ifleft__> 0else__0right__=right__ifright__> 0else__0 self.maxSum = max(self.maxSum, root.val +left__+ right)return__max(left, right) + root.valGithub__(https://github.com/gavinfish/LeetCode-Python) 124Binary__TreeMaximum__PathSum__318LeetCode__ValidPalindrom__: :s__= "A man,a__plan,a__canal: Panama" :True__:s__= "racea__car" :False__AC 125Valid__Palindrome 319class__Solution(object):def__isPalindrome(self, s): """ :type s:str__:rtype:bool__"""alphanumericS__= [cfor__cin__s.lower()if__c.isalnum()]return__alphanumericS == alphanumericS[::-1]if____name__ == "__main__":assert__Solution().isPalindrome("A man,a__plan,a__canal:Pana__ma") ==True__assert Solution().isPalindrome("racea__car") ==False__Github (https://github.com/gavinfish/LeetCode-Python) 125Valid__Palindrome 320LeetCode__WordLadder__II : :beginWord__= "hit",endWord__= "cog",wordList__= ["hot","dot","dog","lot","log"] : [ ["hit","hot","dot","dog","cog"], ["hit","hot","lot","log","cog"] ]Word__LadderDFS__1.Word__LadderABB__AABC 126Word__LadderII__321is_forward__2.bit__himbim__3.hit__{"hot","hat","bit","him","bot","bim"}AC__class Solution(object):def__findLadders(self, beginWord, endWord, wordlist): """ :type beginWord:str__:type endWord:str__:type wordlist: Set[str] :rtype: List[List[int]] """def__bfs(front_level, end_level, is_forward, word_set,pa__th_dic):if__len(front_level) == 0:return__Falseif__len(front_level) > len(end_level):return__bfs(end_level, front_level,not__is_forwar 126Word__LadderII__322 d, word_set, path_dic)for__wordin__(front_level | end_level): word_set.discard(word)next_level__= set()done__=False__while front_level:word__= front_level.pop()for__cin__'abcdefghijklmnopqrstuvwxyz':for__iin__range(len(word)):new_word__= word[:i] +c__+ word[i + 1:]if__new_wordin__end_level:done__=True__add_path(word, new_word, is_forward, path_dic) else:if__new_wordin__word_set: next_level.add(new_word) add_path(word, new_word,is_forw__ard, path_dic)return__doneor__bfs(next_level, end_level,is_forward__, word_set, path_dic)def__add_path(word, new_word, is_forward, path_dic):if__is_forward: path_dic[word] = path_dic.get(word, []) + [new_w ord] else: path_dic[new_word] = path_dic.get(new_word, []) + [word]def__construct_path(word, end_word, path_dic, path, paths) :if__word == end_word: paths.append(path)return__ifword__in path_dic:for__itemin__path_dic[word]: construct_path(item, end_word, path_dic,pat__h + [item], paths) 126Word__LadderII__323 front_level,end_level__= {beginWord}, {endWord}path_dic__= {} bfs(front_level, end_level, True, wordlist, path_dic) path,paths__= [beginWord], [] construct_path(beginWord, endWord, path_dic, path,paths__)return__pathsif____name__ == "__main__":assert__Solution().findLadders("hit", "cog", {"hot", "dot", " dog", "lot", "log"}) == [ ["hit", "hot", "dot", "dog", "cog"], ["hit", "hot", "lot", "log", "cog"] ]Github__(https://github.com/gavinfish/LeetCode-Python) 126Word__LadderII__324LeetCode__WordLadder__0 : :beginWord__= "hit",endWord__= "cog",wordList__= ["hot","dot","dog","lot","log"] : 5 ("hit" -> "hot" -> "dot" -> "dog" -> "cog") 1. 2.hot__hutbot__3. 4.bit__himbim__127Word__Ladder 325bim__bim 5. 3 4 6. 0hit__{"hot","hat","bit","him","bot","bim"}AC__127Word__Ladder 326class__Solution(object):def__ladderLength(self, beginWord, endWord, wordList): """ :type beginWord:str__:type endWord:str__:type wordList: Set[str] :rtype:int__""" wordList.add(endWord)cur_level__= [beginWord]next_level__= []depth__= 1n__= len(beginWord)while__cur_level:for__itemin__cur_level:if__item == endWord:return__depthfor__iin__range(n):for__cin__'abcdefghijklmnopqrstuvwxyz':word__= item[:i] +c__+ item[i + 1:]if__wordin__wordList: wordList.remove(word) next_level.append(word)depth__+= 1cur_level__=next_level__next_level = []return__0if____name__ == "__main__":assert__Solution().ladderLength("hit", "cog", {"hot", "dot", "dog", "lot", "log"}) == 5Github__(https://github.com/gavinfish/LeetCode-Python) 127Word__Ladder 327LeetCode__LongestConsecutive__Sequence O(n) : :nums__= [100, 4, 200, 1, 3, 2] : 4 ( [1,2,3,4])AC__128Longest__ConsecutiveSequence__328class__Solution(object):def__longestConsecutive(self, nums): """ :type nums: List[int] :rtype:int__""" numset,maxlen__= set(nums), 0for__nin__set(nums): currlen,tmp__= 1,n__+ 1while__tmpin__numset:currlen__+= 1 numset.discard(tmp)tmp__+= 1tmp__=n__- 1while__tmpin__numset:currlen__+= 1 numset.discard(tmp)tmp__-= 1maxlen__= max(maxlen, currlen)return__maxlenif____name__ == "__main__":assert__Solution().longestConsecutive([100, 4, 200, 1, 3, 2]) == 4Github__(https://github.com/gavinfish/LeetCode-Python) 128Longest__ConsecutiveSequence__329LeetCode__SumRoot__toLeaf__Numbers 0-9 : : 1 / \ 2 3 : 25 10s__AC 129Sum__Rootto__LeafNumbers__330 #Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__sumNumbers(self, root): """ :type root:TreeNode__:rtype:int__"""return__self._sumNumbers(root, 0)def___sumNumbers(self, root, s):if__rootis__None:return__0s__=s__* 10 + root.valreturn__sum([self._sumNumbers(r, s)for__rin__(root.left, root.right)])or__sif____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 129Sum__Rootto__LeafNumbers__331LeetCode__SurroundedRegions__"X" "O" "X" "O" "X" : :XXXX__XOOXXXOX__XOXX :XXXX__XXXXXXXX__XOXXXOOX__OXOOXOO__130Surrounded__Regions 332X__OO__OX__ACclass__Solution(object):def__solve(self, board): """ :type board: List[List[str]] :rtype:void__Donot__return anything,modify__board in-place__instead. """if__notboard__ornot__board[0]:return__n = len(board)m__= len(board[0])queue__= [] #Get__all 'O'on__edgefor__iin__range(n):for__jin__range(m):if__((iin__(0,n__- 1))or__(jin__(0,m__- 1)))and__board[i][j] == 'O': queue.append((i, j)) #Mark__all 'O'which__canconnect__to 'O'on__edgewhile__queue: r,c__= queue.pop(0)if__0 <=r__<n__and 0 <=c__<m__and board[r][c] == 'O': board[r][c] = 'M'if__r - 1 >= 0and__board[r - 1][c] == 'O': queue.append((r - 1, c))if__r + 1 <n__and board[r + 1][c] == 'O': queue.append((r + 1, c))if__c - 1 >= 0and__board[r][c - 1] == 'O': queue.append((r,c__- 1))if__c + 1 <m__and board[r][c + 1] == 'O': queue.append((r,c__+ 1)) #Update__characters 130Surrounded__Regions 333for__iin__range(n):for__jin__range(m):if__board[i][j] == 'M': board[i][j] = 'O' else: board[i][j] = 'X'if____name__ == "__main__":board__= [ ['X', 'X', 'X', 'X'], ['X', 'O', 'O', 'X'], ['X', 'X', 'O', 'X'], ['X', 'O', 'X', 'X'] ]expected_board__= [ ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'O', 'X', 'X'] ] Solution().solve(board)assert__board ==expected_board__Github (https://github.com/gavinfish/LeetCode-Python) 130Surrounded__Regions 334LeetCode__PalindromePartitioning__: :s__= "aab" :result__= [["a", "a", "b"], ["aa", "b"]]AC__131Palindrome__Partitioning 335class__Solution(object):def__partition(self, s): """ :type s:str__:rtype: List[List[str]] """if__not s:return__[[]]result__= []for__iin__range(len(s)):if__self.isPalindrome(s[:i + 1]):for__rin__self.partition(s[i + 1:]): result.append([s[:i + 1]] + r)return__resultdef__isPalindrome(self, s):return__s == s[::-1]if____name__ == "__main__":assert__Solution().partition("aab") == [ ["a", "a", "b"], ["aa", "b"] ]Github__(https://github.com/gavinfish/LeetCode-Python) 131Palindrome__Partitioning 336LeetCode__PalindromePartitioning__II : :s__= "aab" : 1 ( "aa" "b") dp[i] s[:i+1] dp[i]i__i+1i__0 dp[i] = 0, s[:i+1] dp[i] = min(dp[i], dp[j-1]+1), s[j:i+1] isPal[j][i] isPal[j][i] s[j:i+1]AC__132Palindrome__PartitioningII__337class__Solution(object):def__minCut(self, s): """ :type s:str__:rtype: List[List[str]] """n__= len(s)dp__= [0for____in__range(n)]isPal__= [[Falsefor____in__range(n)]for____in__range(n)]for__iin__range(n):m__=i__forj__in range(i + 1):if__s[j] == s[i]and__(j + 1 >i__- 1or__isPal[j + 1 ][i - 1]): isPal[j][i] =True__m = 0if__j == 0else__min(m, dp[j - 1] + 1) dp[i] =m__return dp[-1]if____name__ == "__main__":assert__Solution().minCut("aab") == 1Github__(https://github.com/gavinfish/LeetCode-Python) 132Palindrome__PartitioningII__338LeetCode__CloneGraph__: : 1 / \ / \ 0 --- 2 / \ \_/ : 1 / \ / \ 0 --- 2 / \ \_/ 133Clone__Graph 339AC__133Clone__Graph 340 #Definition__fora__undirectedgraph__nodeclass__UndirectedGraphNode(object):def____init__(self, x): self.label =x__self.neighbors = []class__Solution(object):def__cloneGraph(self, node): """ :type node:UndirectedGraphNode__:rtype:UndirectedGraphNode__"""if__not node:return__nodevisited__= {}first__= UndirectedGraphNode(node.label) visited[node.label] =first__stack = [node]while__stack:top__= stack.pop()for__nin__top.neighbors:if__n.labelnot__in visited: visited[n.label] = UndirectedGraphNode(n.lab el) stack.append(n) visited[top.label].neighbors.append(visited[n.la bel])return__firstif____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 133Clone__Graph 341 133Clone__Graph 342LeetCode__GasStation__N gas[i]i__i+1 cost[i] -1 : :gas__= [5, 1, 2, 3, 4],cost__= [4, 4, 1, 5, 1] : 4 gas>cost c[i] = gas[i] - cost[i] c[i]c__c 0cost__gascost__gas c[0]+c[1]+...+c[n-2]+c[n-1]>=0 cii=j 134Gas__Station 343 c[0]+c[1]+...+c[j-1]<=c[0]+c[1]+...c[j] c[0]+c[1]+...+c[j-1]<=c[0]+c[1]+...c[j]+c[j+1] ... c[0]+c[1]+...+c[j-1]<=c[0]+c[1]+...c[j]+c[j+1]+...+c[n-1] c[j]>=0 c[j]+c[j+1]>=0 ... c[j]+c[j+1]+...+c[n-1]>=0j__c[0]+c[1]+...+c[j-1]<=c[0]+c[1]+...+c[j-2] c[0]+c[1]+...+c[j-1]<=c[0]+c[1]+...+c[j-3] ... c[0]+c[1]+...+c[j-1]<=c[0] c[j-1]<=0 c[j-2]+c[j-1]<=0 ... c[1]+c[1]+...+c[j-1]<=0 c[0]+c[1]+...+c[n-2]+c[n-1]>=0 c[j]+c[j+1]+...+c[n-1]+c[0]+c[1]+...+c[j-2]>=0 c[j]+c[j+1]+...+c[n-1]+c[0]+c[1]+...+c[j-3]>=0 c[j]+c[j+1]+...+c[n-1]+c[0]>=0j__cj__134Gas__Station 344AC__class Solution(object):def__canCompleteCircuit(self, gas, cost): """ :type gas: List[int] :type cost: List[int] :rtype:int__"""if__sum(gas) < sum(cost):return__-1 min_sum, min_index,total__= 0, 0, 0for__iin__range(len(gas)):total__+= gas[i] - cost[i]if__min_sum > total: min_sum,min_index__= total,i__+ 1return__-1if__total < 0else__min_indexif____name__ == "__main__":assert__Solution().canCompleteCircuit([5], [4]) == 0assert__Solution().canCompleteCircuit([5, 1, 2, 3, 4], [4, 4, 1, 5, 1]) == 4Github__(https://github.com/gavinfish/LeetCode-Python) 134Gas__Station 345LeetCode__CandyN__: :ratings__= [1, 2, 3, 2] : 7 1,2,3...AC__135Candy__346class__Solution(object):def__candy(self, ratings): """ :type ratings: List[int] :rtype:int__"""n__= len(ratings)candy__= [1] *n__fori__in range(1, n):if__ratings[i] > ratings[i - 1]: candy[i] = candy[i - 1] + 1for__iin__range(n - 2, -1, -1):if__ratings[i] > ratings[i + 1]: candy[i] = max(candy[i], candy[i + 1] + 1)return__sum(candy)if____name__ == "__main__":assert__Solution().candy([1, 2, 3, 7, 4, 3, 2, 1]) == 21Github__(https://github.com/gavinfish/LeetCode-Python) 135Candy__347LeetCode__SingleNumber__O(n) O(1) : :nums__= [1, 2, 3, 4, 3, 2, 1] : 4 0 0 a^b=b^aAC__136Single__Number 348class__Solution(object):def__singleNumber(self, nums): """ :type nums: List[int] :rtype:int__"""result__= nums[0]for__iin__nums[1:]:result__^=i__returnresult__if__name____== "__main__":assert__Solution().singleNumber([1, 2, 3, 4, 3, 2, 1]) == 4Github__(https://github.com/gavinfish/LeetCode-Python) 136Single__Number 349LeetCode__SingleNumber__II : :nums__= [1, 1, 1, 2, 3, 3, 3] : 2one__=one__|num__->num__,two__=two__|one__&num__->num__,three__=two__&num__->num__n 32int__32n__PythonPython__0AC__137Single__NumberII__350class__Solution(object):def__singleNumber(self, nums): """ :type nums: List[int] :rtype:int__""" one, two,three__= 0, 0, 0for__numin__nums: #calculate__thecount__ofthe__eachbit__three =two__&num__two =two__|one__&num__one =one__|num__#clear__thecount__forthe__bitwhich__hasachieved__three__one =one__& ~threetwo__=two__& ~threereturn__onedef__singleNumber_normal(self, nums):result__= 0for__iin__range(32):count__= 0for__numin__nums:count__+= (num >> i) & 1rem__=count__% 3 #deal__withthe__negativesituation__ifi__== 31and__rem:result__-= 1 << 31 else:result__|=rem__<<i__returnresult__if__name____== "__main__":assert__Solution().singleNumber([1, 1, 1, 2, 3, 3, 3]) == 2assert__Solution().singleNumber([-2, -2, 1, 1, -3, 1, -3, -3, -4, -2]) == -4assert__Solution().singleNumber_normal([1, 1, 1, 2, 3, 3, 3]) == 2assert__Solution().singleNumber_normal([-2, -2, 1, 1, -3, 1, 137Single__NumberII__351 -3, -3, -4, -2]) == -4Github__(https://github.com/gavinfish/LeetCode-Python) 137Single__NumberII__352LeetCode__CopyList__withRandom__Pointer : : :AC__138Copy__Listwith__RandomPointer__353 #Definition__for singly-linkedlist__witha__random pointer.class__RandomListNode(object):def____init__(self, x): self.label =x__self.next =None__self.random =None__class Solution(object):def__copyRandomList(self, head): """ :type head:RandomListNode__:rtype:RandomListNode__"""if__not head:return__Nonevisited__= dict()node__=head__while node: visited[node] = RandomListNode(node.label)node__= node.next visited[None] =None__node =head__while node: visited[node].next = visited[node.next] visited[node].random = visited[node.random]node__= node.nextreturn__visited[head]if____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 138Copy__Listwith__RandomPointer__354 138Copy__Listwith__RandomPointer__355LeetCode__WordBreak__: :s__= "leetcode",wordDict__= {"leet", "code"} :True__dp[i] s[:i] s[j:i] dp[j]True__s[:j] dp[i]True__AC 139Word__Break 356class__Solution(object):def__wordBreak(self, s, wordDict): """ :type s:str__:type wordDict: Set[str] :rtype:bool__"""n__= len(s)dp__= [False] * (n + 1) dp[0] =True__fori__in range(n):for__jin__range(i, -1, -1):if__dp[j]and__s[j:i + 1]in__wordDict: dp[i + 1] =True__breakreturn__dp[n]if____name__ == "__main__":assert__Solution().wordBreak("leetcode", {"leet", "code"}) ==True__Github (https://github.com/gavinfish/LeetCode-Python) 139Word__Break 357LeetCode__WordBreak__II : :s__= "catsanddog",dict__= ["cat", "cats", "and", "sand", "dog"] : ["catsand__dog", "catsand__dog"]dfs__abcd... {a,b,c,ab,bc,abc}d__AC 140Word__BreakII__358import__collectionsclass__Solution(object):def__wordBreak(self, s, wordDict): """ :type s:str__:type wordDict: Set[str] :rtype: List[str] """dic__= collections.defaultdict(list)def__dfs(s):if__not s:return__[None]if__sin__dic:return__dic[s]res__= []for__wordin__wordDict:n__= len(word)if__s[:n] == word:for__rin__dfs(s[n:]):if__r: res.append(word + " " + r) else: res.append(word) dic[s] =res__returnres__return dfs(s)if____name__ == "__main__":assert__Solution().wordBreak("catsanddog", {"cat", "cats", "a nd", "sand", "dog"}) == ['catsand__dog', 'catsand__dog']Github__(https://github.com/gavinfish/LeetCode-Python) 140Word__BreakII__359 140Word__BreakII__360LeetCode__LinkedList__Cycle : : 1->2->3 | | 5<-4 :True__AC 141Linked__ListCycle__361 #Definition__for singly-linked list.class__ListNode(object):def____init__(self, x): self.val =x__self.next =None__class Solution(object):def__hasCycle(self, head): """ :type head:ListNode__:rtype:bool__"""slow__=fast__=head__whilefast__and fast.next:slow__= slow.nextfast__= fast.next.nextif__slow == fast:return__Truereturn__Falseif____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 141Linked__ListCycle__362LeetCode__LinkedList__CycleII__: : 1->2->3 | | 5<-4 : 2Linked__ListCycle__AB__C (x+y+z+y) (x+y) x+y+z+y = 2(x+y) x=zCAB__ACB 142Linked__ListCycle__II 363C__ABn__x+y+n(z+y) = 2(x+y) x=(n-1)(y+z)+zC__n-1z__AB__AC 142Linked__ListCycle__II 364 #Definition__for singly-linked list.class__ListNode(object):def____init__(self, x): self.val =x__self.next =None__class Solution(object):def__detectCycle(self, head): """ :type head:ListNode__:rtype:ListNode__"""slow__=fast__=head__whilefast__and fast.next:slow__= slow.nextfast__= fast.next.nextif__slow == fast:node__=head__whilenode__!= slow:node__= node.nextslow__= slow.nextreturn__nodereturn__Noneif____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 142Linked__ListCycle__II 365LeetCode__ReorderList__L0 L1 Ln-1Ln__L0Ln__L1 Ln-1 L2 Ln-2 : : {1,2,3,4} : {1,4,2,3}AC__143Reorder__List 366class__Solution(object):def__reorderList(self, head): """ :type head:ListNode__:rtype:void__Donot__return anything,modify__head in-place__instead. """if__not head:return__#split__fast =slow__=head__whilefast__and fast.next:slow__= slow.nextfast__= fast.next.next head1, head2 = head, slow.next slow.next =None__#reverse__cur,pre__= head2,None__while cur:nex__= cur.next cur.next =pre__pre =cur__cur =nex__#merge__cur1, cur2 = head1,pre__while cur2: nex1, nex2 = cur1.next, cur2.next cur1.next = cur2 cur2.next = nex1 cur1, cur2 = nex1, nex2if____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 143Reorder__List 367 143Reorder__List 368LeetCode__BinaryTree__PreorderTraversal__: : 1 \ 2 / 3 : [1,2,3] 144Binary__TreePreorder__Traversal 369AC__#Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__preorderTraversal(self, root): """ :type root:TreeNode__:rtype: List[int] """stack__= []result__= []while__rootor__stack:if__not root:root__= stack.pop() result.append(root.val)if__root.right: stack.append(root.right)root__= root.leftreturn__resultif____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 144Binary__TreePreorder__Traversal 370LeetCode__BinaryTree__PostorderTraversal__: : 1 \ 2 / 3 : [3,2,1]visit__get 145Binary__TreePostorder__Traversal 371AC__#Definition__fora__binarytree__node.class__TreeNode(object):def____init__(self, x): self.val =x__self.left =None__self.right =None__class Solution(object):def__postorderTraversal(self, root): """ :type root:TreeNode__:rtype: List[int] """if__not root:return__[]result__= []stack__= [(root, 'visit')]while__stack: node,label__= stack.pop()if__label == 'visit': stack.append((node, 'get'))if__node.right: stack.append((node.right, 'visit'))if__node.left: stack.append((node.left, 'visit')) else: result.append(node.val)return__resultif____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 145Binary__TreePostorder__Traversal 372 145Binary__TreePostorder__Traversal 373LeetCode__LRUCache__-1 : -1AC__class LRUCache(object): 146LRU__Cache 374class__Node(object):def____init__(self, key, value): self.key =key__self.value =value__self.prev, self.next = None,None__def __init__(self, capacity): """ :type capacity:int__""" self.capacity, self.size = capacity, 0 self.dic = {} self.head, self.tail = self.Node(-1, -1), self.Node(-1, -1) self.head.next, self.tail.prev = self.tail, self.headdef____remove(self, node): node.prev.next = node.next node.next.prev = node.prev node.prev, node.next = None,None__def __insert(self, node): node.prev, node.next = self.head, self.head.next self.head.next.prev =node__self.head.next =node__def get(self, key): """ :rtype:int__"""if__keynot__in self.dic:return__-1node__= self.dic[key] self.__remove(node) self.__insert(node)return__node.valuedef__set(self, key, value): """ :type key:int__146LRU__Cache 375 :type value:int__:rtype:nothing__"""if__keyin__self.dic:node__= self.dic[key] self.__remove(node) node.value =value__self.__insert(node) else:if__self.size == self.capacity:discard__= self.tail.prev self.__remove(discard)del__self.dic[discard.key] self.size -= 1node__= self.Node(key, value) self.dic[key] =node__self.__insert(node) self.size += 1if____name__ == "__main__":lru_cache__= LRUCache(3) lru_cache.set(1, 1) lru_cache.set(2, 2) lru_cache.set(3, 3)assert__lru_cache.get(0) == -1assert__lru_cache.get(1) == 1 lru_cache.set(1, 10)assert__lru_cache.get(1) == 10 lru_cache.set(4, 4)assert__lru_cache.get(2) == -1Github__(https://github.com/gavinfish/LeetCode-Python) 146LRU__Cache 376LeetCode__InsertionSort__List :Python__AC 147Insertion__SortList__377 #Definition__for singly-linked list.class__ListNode(object):def____init__(self, x): self.val =x__self.next =None__class Solution(object):def__insertionSortList(self, head): """ :type head:ListNode__:rtype:ListNode__"""dummy__= ListNode(-1)cur__=dummy__while head: #check__ifit__isneeded__toreset__thecur__pointerif__curand__cur.val > head.val:cur__=dummy__#find__theplace__toinsert__while cur.nextand__cur.next.val < head.val:cur__= cur.next #insert__andsort__thenext__element cur.next, cur.next.next,head__= head, cur.next,head__.nextreturn__dummy.nextif____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 147Insertion__SortList__378LeetCode__MaxPoints__ona__Linen__:A__AABCD__ABBC 4B__CA__BCB__BAC__#Definition__fora__point.class__Point(object):def____init__(self, a=0, b=0): 149Max__Pointson__aLine__379 self.x =a__self.y =b__class Solution(object):def__maxPoints(self, points): """ :type points: List[Point] :rtype:int__"""n__= len(points)slope_map__= {}result__= 0for__iin__range(n): slope_map.clear() same,vertical__= 1, 0slope_max__= 0for__jin__range(i + 1, n): dx,dy__= points[i].x - points[j].x, points[i].y - points[j].yif__dx ==dy__== 0:same__+= 1elif__dx == 0:vertical__+= 1 else:slope__= float(dy) / float(dx) slope_map[slope] = slope_map.get(slope, 0) + 1slope_max__= max(slope_max, slope_map[slope])result__= max(result, max(slope_max, vertical) +same__)return__resultif____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 149Max__Pointson__aLine__380 149Max__Pointson__aLine__381LeetCode__EvaluateReverse__PolishNotation__: :tokens__= ["2", "1", "+", "3", "*"] : 9 1 2Python__Python -1//2 -1 0AC__150Evaluate__ReversePolish__Notation 382class__Solution(object):def__evalRPN(self, tokens): """ :type tokens: List[str] :rtype:int__"""stack__= []for__tokenin__tokens:if__tokennot__in ("+", "-", "*", "/"): stack.append(int(token)) else:second__= stack.pop()first__= stack.pop()if__token == "+": stack.append(first + second)elif__token == "-": stack.append(first - second)elif__token == '*': stack.append(first * second) else:if__first *second__< 0: stack.append(-(abs(first) // abs(second) )) else: stack.append(first // second)return__stack.pop()if____name__ == "__main__":assert__Solution().evalRPN(["2", "1", "+", "3", "*"]) == 9assert__Solution().evalRPN(["4", "13", "5", "/", "+"]) == 6assert__Solution().evalRPN(["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]) == 22Github__(https://github.com/gavinfish/LeetCode-Python) 150Evaluate__ReversePolish__Notation 383 150Evaluate__ReversePolish__Notation 384LeetCode__ReverseWords__ina__String "thesky__is blue" "blueis__sky the" : :s__= "thesky__is blue" : "blueis__sky the"Python__Pythonpythonic__AC 151Reverse__Wordsin__aString__385class__Solution(object):def__reverseWords(self, s): """ :type s:str__:rtype:str__"""return__" ".join(s.split()[::-1])if____name__ == "__main__":assert__Solution().reverseWords("thesky__isblue__") == "blueis__sky the"Github__(https://github.com/gavinfish/LeetCode-Python) 151Reverse__Wordsin__aString__386LeetCode__MaximumProduct__Subarray : :nums__= [2,3,-2,4] : 6temp__=positive__positive = max(num,positive__* num,negative__* num)negative__= min(num,temp__* num,negative__* num)positive__negativeAC__152Maximum__ProductSubarray__387class__Solution(object):def__maxProduct(self, nums): """ :type nums: List[int] :rtype:int__""" positive,negative__= nums[0], nums[0]result__= nums[0]for__numin__nums[1:]: positive,negative__= max(num,positive__* num,negati__ve * num), min(num,positive__* num,negative__* num)result__= max(result, positive)return__resultif____name__ == "__main__":assert__Solution().maxProduct([2, 3, -2, 4]) == 6Github__(https://github.com/gavinfish/LeetCode-Python) 152Maximum__ProductSubarray__388LeetCode__MinStack__O(1) :MinStack__minStack =new__MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); -->Returns__-3. minStack.pop(); minStack.top(); -->Returns__0. minStack.getMin(); -->Returns__-2. O(n) 155Min__Stack 389AC__class MinStack(object):def____init__(self): """initialize__yourdata__structure here. """ self.stack = [] self.minStack = []def__push(self, x): """ :type x:int__:rtype:nothing__""" self.stack.append(x)if__not self.minStack: self.minStack.append(x) else:if__self.minStack[-1] >= x: self.minStack.append(x)def__pop(self): """ :rtype:nothing__"""if__self.stack:if__self.minStack[-1] == self.stack[-1]: self.minStack.pop() self.stack.pop()def__top(self): """ :rtype:int__"""if__self.stack:return__self.stack[-1]def__getMin(self): 155Min__Stack 390 """ :rtype:int__"""if__self.minStack:return__self.minStack[-1]if____name__ == "__main__":minStack__= MinStack() minStack.push(4) minStack.push(5) minStack.push(1) minStack.push(3)assert__minStack.getMin() == 1 minStack.pop() minStack.pop()assert__minStack.top() == 5Github__(https://github.com/gavinfish/LeetCode-Python) 155Min__Stack 391LeetCode__Intersectionof__TwoLinked__ListsNone__O(n) O(1) : A: a1 a2 c1 c2 c3 B: b1 b2 b3 c1 160Intersection__ofTwo__LinkedLists__392A__BBALinked__ListCycle__IIA__AC #Definition__for singly-linked list.class__ListNode(object):def____init__(self, x): self.val =x__self.next =None__class Solution(object):def__getIntersectionNode(self, headA, headB): """ :type head1, head1:ListNode__:rtype:ListNode__""" nodeA,nodeB__= headA,headB__whilenodeA__!= nodeB:nodeA__= nodeA.nextif__nodeAelse__headBnodeB__= nodeB.nextif__nodeBelse__headAreturn__nodeAdef__getIntersectionNode_diff(self, headA, headB): """ :type head1, head1:ListNode__:rtype:ListNode__"""def__get_length(node):length__= 0 160Intersection__ofTwo__LinkedLists__393while__node:node__= node.nextlength__+= 1return__length len1 = get_length(headA) len2 = get_length(headB)if__len1 > len2:for____in__range(len1 - len2):headA__= headA.next else:for____in__range(len2 - len1):headB__= headB.nextwhile__headA:if__headA == headB:return__headAheadA__= headA.nextheadB__= headB.nextreturn__Noneif____name__ == "__main__":None__Github (https://github.com/gavinfish/LeetCode-Python) 160Intersection__ofTwo__LinkedLists__394LeetCode__FindPeak__Element [1] 0 log(n) : :nums__= [1, 2, 3, 1] : 2 /\ / \/\ /\ / \/ \ / \ log(n) 162Find__PeakElement__395AC__class Solution(object):def__findPeakElement(self, nums): """ :type nums: List[int] :rtype:int__""" left,right__= 0, len(nums) - 1while__left < right:mid__= (right + left) // 2if__nums[mid] < nums[mid + 1]:left__=mid__+ 1 else:right__=mid__returnleft__if__name____== "__main__":assert__Solution().findPeakElement([1, 2, 3, 1]) == 2Github__(https://github.com/gavinfish/LeetCode-Python) 162Find__PeakElement__396LeetCode__Fractionto__RecurringDecimal__: :numerator__= 1,denominator__= 2 : "0.5" :numerator__= 2,denominator__= 3 : "0.(6)" 0 "(0)"AC__166Fraction__toRecurring__Decimal 397class__Solution(object):def__fractionToDecimal(self, numerator, denominator): """ :type numerator:int__:type denominator:int__:rtype:str__"""sign__= '-'if__numerator *denominator__< 0else__'' quotient,remainder__= divmod(abs(numerator), abs(denomin ator))result_list__= [sign, str(quotient), '.']remainders__= []while__remaindernot__in remainders: remainders.append(remainder) quotient,remainder__= divmod(remainder * 10, abs(den ominator)) result_list.append(str(quotient))idx__= remainders.index(remainder) result_list.insert(idx + 3, '(') result_list.append(')')result__= ''.join(result_list).replace('(0)', '').rstrip( '.')return__resultif____name__ == "__main__":assert__Solution().fractionToDecimal(1, 2) == '0.5'assert__Solution().fractionToDecimal(2, 1) == '2'assert__Solution().fractionToDecimal(2, 3) == '0.(6)'Github__(https://github.com/gavinfish/LeetCode-Python) 166Fraction__toRecurring__Decimal 398LeetCode__ExcelSheet__ColumnTitle__Excel A,B,C...AA,AB... : :n__= 1 : 'A' :n__= 28 : 'AB' 26AC__168Excel__SheetColumn__Title 399class__Solution(object):def__convertToTitle(self, n): """ :type n:int__:rtype:str__"""result__= []base__= ord('A')while__n: n,r__= divmod(n - 1, 26) result.append(chr(base + r))return__''.join(result[::-1])if____name__ == "__main__":assert__Solution().convertToTitle(1) == 'A'assert__Solution().convertToTitle(28) == 'AB'Github__(https://github.com/gavinfish/LeetCode-Python) 168Excel__SheetColumn__Title 400LeetCode__MajorityElement__: :nums__= [1, 2, 2, 3, 3, 3, 3] : 3 0AC__169Majority__Element 401class__Solution(object):def__majorityElement(self, nums): """ :type nums: List[int] :rtype:int__"""result__=None__count = 0for__numin__nums:if__count == 0:result__=num__ifresult__== num:count__+= 1 else:count__-= 1return__resultif____name__ == "__main__":assert__Solution().majorityElement([1, 2, 2, 3, 3, 3, 3]) == 3assert__Solution().majorityElement([3, 3, 3, 3, 1, 1, 2]) == 3Github__(https://github.com/gavinfish/LeetCode-Python) 169Majority__Element 402LeetCode__ExcelSheet__ColumnNumber__Excel A,B,C...AA,AB...Excel__A 1 : :s__= 'A' : 1 :s__= 'AB' : 28 1,2,3...A,B,...Q A,B,C...Z 26AC__171Excel__SheetColumn__Number 403class__Solution(object):def__titleToNumber(self, s): """ :type s:str__:rtype:int__"""base__= ord('A') - 1n__= len(s)result__= 0for__iin__range(n):result__+= (ord(s[n - 1 - i]) - base) * pow(26, i)return__resultif____name__ == "__main__":assert__Solution().titleToNumber('A') == 1assert__Solution().titleToNumber('AB') == 28Github__(https://github.com/gavinfish/LeetCode-Python) 171Excel__SheetColumn__Number 404LeetCode__FactorialTrailing__Zeroesn__log(n) : :n__= 5 : 1 10 2 5n__2 5 5 1n__5 5 25 2 5 5 ...n__5 5AC__172Factorial__TrailingZeroes__405class__Solution(object):def__trailingZeroes(self, n): """ :type n:int__:rtype:int__"""count__= 0while__n:n__//= 5count__+=n__returncount__if__name____== "__main__":assert__Solution().trailingZeroes(25) == 6Github__(https://github.com/gavinfish/LeetCode-Python) 172Factorial__TrailingZeroes__406LeetCode__BinarySearch__TreeIterator__next() next() hasNext() O(1) O(n)n__: next() hasNext() next() i.hasNext(): v.append(i.next())AC__#Definition__fora__binarytree__node #class__TreeNode(object): 173Binary__SearchTree__Iterator 407 #def____init__(self, x): # self.val =x__# self.left =None__# self.right =None__class BSTIterator(object):def____init__(self, root): """ :type root:TreeNode__""" self.stack = [] self._pushLeft(root)def__hasNext(self): """ :rtype:bool__"""return__self.stackdef__next(self): """ :rtype:int__"""node__= self.stack.pop() self._pushLeft(node.right)return__node.valdef___pushLeft(self, node):while__node: self.stack.append(node)node__= node.left #Your__BSTIteratorwill__becalled__like this: # i,v__= BSTIterator(root), [] #while__i.hasNext(): v.append(i.next())if____name__ == "__main__":None__173Binary__SearchTree__Iterator 408Github__(https://github.com/gavinfish/LeetCode-Python) 173Binary__SearchTree__Iterator 409LeetCode__DungeonGame__0 0 : : -2 (K) | -3 | 3 -5 | -10 | 1 10 | 30 | -5 (P) : 7 ( -> -> -> )dp__: 174Dungeon__Game 410 dp[j][i] = max(min(dp[j + 1][i], dp[j][i + 1]) - dungeon[j][i], 1) (j,i) dp[j][i] dp[j][i+1] dp[j+1][i] dp[j][i] dp[j][i] + dungeon[j][i] = min(dp[j + 1][i], dp[j][i + 1] dp[j][i] 0AC__class Solution(object):def__calculateMinimumHP(self, dungeon): """ :type dungeon: List[List[int]] :rtype:int__"""n__= len(dungeon)m__= len(dungeon[0])dp__= [[0for____in__range(m)]for____in__range(n)] dp[-1][-1] = 1if__dungeon[-1][-1] > 0else__1 - dungeon[-1 ][-1]for__iin__range(m - 2, -1, -1): dp[-1][i] = max(1, dp[-1][i + 1] - dungeon[-1][i])for__jin__range(n - 2, -1, -1): dp[j][-1] = max(1, dp[j + 1][-1] - dungeon[j][-1])for__jin__range(n - 2, -1, -1):for__iin__range(m - 2, -1, -1): dp[j][i] = max(min(dp[j + 1][i], dp[j][i + 1]) - dungeon[j][i], 1)return__dp[0][0]if____name__ == "__main__":assert__Solution().calculateMinimumHP([[-2, -3, 3], [-5, -10, 1], [10, 30, -5]]) == 7 174Dungeon__Game 411Github__(https://github.com/gavinfish/LeetCode-Python) 174Dungeon__Game 412LeetCode__LargestNumber__: :nums__= [3, 30, 34, 5, 9] : '9534330' 12 121 121>12 12121>12112 AB>BA A>BAB @19thhell 179Largest__Number 413 f(X) = 10^(lgX + 1), (lgX + 1)X__AB = f(B)A +B__A < B,B__<C__<AB__< BA,BC__<CB__AB <BA__f(B)A +B__< f(A)B +A__(f(B) - 1)A < (f(A) - 1)BA__<B__(f(A) - 1) / (f(B) - 1) (1)BC__<CB__f(C)B +C__< f(B)C +B__(f(C) - 1)B < (f(B) - 1)CB__<C__(f(B) - 1) / (f(C) - 1) (2) (1), (2)A__<C__(f(A) - 1) / (f(C) - 1) (f(C) - 1)A < (f(A) - 1)C f(C)A +C__< f(A)C +A__AC <CA__A <C__A1 > A2 > ... > A(n-1) A1A2...A(n-1)A__<B__CAD <CBD__3) A1 > A2 > ... > A(n-1) A1Aj > AjA1 3 (A1B)C...N > (BA1)C...N B(A1C)...N > B(CA1)...N -> A1BC...N > BCA1...N ... ... -> A1BC...N > BCA...NA1 A1 A2 ...... 179Largest__Number 414 0 0 0AC__fromfunctools__importcmp_to_key__class Solution: # @param {integer[]}nums__# @return {string}def__largestNumber(self, nums):sorted_nums__= sorted(map(str, nums), key=cmp_to_key(lambda__x, y: int(y + x) - int(x + y)))result__= ''.join(sorted_nums).lstrip('0')return__resultor__'0'if____name__ == "__main__":assert__Solution().largestNumber([3, 30, 34, 5, 9]) == '95343 30'assert__Solution().largestNumber([0, 0]) == '0'Github__(https://github.com/gavinfish/LeetCode-Python) 179Largest__Number 415LeetCode__RotateArray__kk__O(1) : :nums__= [1, 2, 3, 4, 5, 6, 7],k__= 3 : [5, 6, 7, 1, 2, 3, 4]k__O(1) O(kn) O(n) O(n)k__kk__O(1) O(n)knknn__AC 189Rotate__Array 416class__Solution(object):def__rotate(self, nums, k): """ :type nums: List[int] :type k:int__:rtype:void__Donot__return anything,modify__nums in-place__instead. """def__reverse(nums, start, end):while__start < end: nums[start], nums[end] = nums[end], nums[start]start__+= 1end__-= 1n__= len(nums)k__%=n__reverse(nums, 0,n__-k__- 1) reverse(nums,n__- k,n__- 1) reverse(nums, 0,n__- 1)if____name__ == "__main__":nums__= [1, 2, 3, 4, 5, 6, 7] Solution().rotate(nums, 10)assert__nums == [5, 6, 7, 1, 2, 3, 4]Github__(https://github.com/gavinfish/LeetCode-Python) 189Rotate__Array 417